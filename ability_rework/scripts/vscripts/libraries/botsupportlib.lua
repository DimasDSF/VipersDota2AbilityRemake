--[[["npc_dota_hero_queenofpain"]		=	"Queen of Pain",
	["npc_dota_hero_antimage"]			=	"Anti-Mage",
	["npc_dota_hero_kunkka"]			=	"Kunkka",
	["npc_dota_hero_lina"]				=	"Lina",
	["npc_dota_hero_mirana"]			=	"Mirana",
	["npc_dota_hero_slardar"]			=	"Slardar",
	["npc_dota_hero_lion"]				=	"Lion",
	["npc_dota_hero_phantom_assassin"]	=	"Phantom Assassin",
	["npc_dota_hero_tidehunter"]		=	"Tidehunter",
	["npc_dota_hero_witch_doctor"]		=	"Witch Doctor",
	["npc_dota_hero_vengefulspirit"]	=	"Vengeful Spirit",
	["npc_dota_hero_juggernaut"]		=	"Juggernaut",
	["npc_dota_hero_earthshaker"]		=	"Earthshaker",
	["npc_dota_hero_pudge"]				=	"Pudge",
	["npc_dota_hero_bane"]				=	"Bane",
	["npc_dota_hero_crystal_maiden"]	=	"Crystal Maiden",
	["npc_dota_hero_sven"]				=	"Sven",
	["npc_dota_hero_skeleton_king"]		=	"Wraith King",
	["npc_dota_hero_storm_spirit"]		=	"Storm Spirit",
	["npc_dota_hero_sand_king"]			=	"Sand King",
	["npc_dota_hero_nevermore"]			=	"Shadow Fiend",
	["npc_dota_hero_drow_ranger"]		=	"Drow Ranger",
	["npc_dota_hero_axe"]				=	"Axe",
	["npc_dota_hero_bloodseeker"]		=	"Bloodseeker",
	["npc_dota_hero_phantom_lancer"]	=	"Phantom Lancer",
	["npc_dota_hero_razor"]				=	"Razor",
	["npc_dota_hero_morphling"]			=	"Morphling",
	["npc_dota_hero_zuus"]				=	"Zeus",
	["npc_dota_hero_tiny"]				=	"Tiny",
	["npc_dota_hero_puck"]				=	"Puck",
	["npc_dota_hero_windrunner"]		=	"Windranger",
	["npc_dota_hero_lich"]				=	"Lich",
	["npc_dota_hero_shadow_shaman"]		=	"Shadow Shaman",
	["npc_dota_hero_riki"]				=	"Riki",
	["npc_dota_hero_enigma"]			=	"Enigma",
	["npc_dota_hero_tinker"]			=	"Tinker",
	["npc_dota_hero_sniper"]			=	"Sniper",
	["npc_dota_hero_necrolyte"]			=	"Necrophos",
	["npc_dota_hero_warlock"]			=	"Warlock",
	["npc_dota_hero_beastmaster"]		=	"Beastmaster",
	["npc_dota_hero_venomancer"]		=	"Venomancer",
	["npc_dota_hero_faceless_void"]		=	"Faceless Void",
	["npc_dota_hero_death_prophet"]		=	"Death Prophet",
	["npc_dota_hero_pugna"]				=	"Pugna",
	["npc_dota_hero_templar_assassin"]	=	"Templar Assassin",
	["npc_dota_hero_viper"]				=	"Viper",
	["npc_dota_hero_luna"]				=	"Luna",
	["npc_dota_hero_dragon_knight"]		=	"Dragon Knight",
	["npc_dota_hero_dazzle"]			=	"Dazzle",
	["npc_dota_hero_rattletrap"]		=	"Clockwerk",
	["npc_dota_hero_leshrac"]			=	"Leshrac",
	["npc_dota_hero_furion"]			=	"Nature's Prophet",
	["npc_dota_hero_life_stealer"]		=	"Lifestealer",
	["npc_dota_hero_dark_seer"]			=	"Dark Seer",
	["npc_dota_hero_clinkz"]			=	"Clinkz",
	["npc_dota_hero_omniknight"]		=	"Omniknight",
	["npc_dota_hero_enchantress"]		=	"Enchantress",
	["npc_dota_hero_huskar"]			=	"Huskar",
	["npc_dota_hero_night_stalker"]		=	"Night Stalker",
	["npc_dota_hero_broodmother"]		=	"Broodmother",
	["npc_dota_hero_bounty_hunter"]		=	"Bounty Hunter",
	["npc_dota_hero_weaver"]			=	"Weaver",
	["npc_dota_hero_jakiro"]			=	"Jakiro",
	["npc_dota_hero_batrider"]			=	"Batrider",
	["npc_dota_hero_chen"]				=	"Chen",
	["npc_dota_hero_spectre"]			=	"Spectre",
	["npc_dota_hero_doom_bringer"]		=	"Doom",
	["npc_dota_hero_ancient_apparition"]=	"Ancient Apparition",
	["npc_dota_hero_ursa"]				=	"Ursa",
	["npc_dota_hero_spirit_breaker"]	=	"Spirit Breaker",
	["npc_dota_hero_gyrocopter"]		=	"Gyrocopter",
	["npc_dota_hero_alchemist"]			=	"Alchemist",
	["npc_dota_hero_invoker"]			=	"Invoker",
	["npc_dota_hero_silencer"]			=	"Silencer",
	["npc_dota_hero_obsidian_destroyer"]=	"Outworld Devourer",
	["npc_dota_hero_lycan"]				=	"Lycan",
	["npc_dota_hero_brewmaster"]		=	"Brewmaster",
	["npc_dota_hero_shadow_demon"]		=	"Shadow Demon",
	["npc_dota_hero_lone_druid"]		=	"Lone Druid",
	["npc_dota_hero_chaos_knight"]		=	"Chaos Knight",
	["npc_dota_hero_treant"]			=	"Treant Protector",
	["npc_dota_hero_meepo"]				=	"Meepo",
	["npc_dota_hero_ogre_magi"]			=	"Ogre Magi",
	["npc_dota_hero_undying"]			=	"Undying",
	["npc_dota_hero_rubick"]			=	"Rubick",
	["npc_dota_hero_disruptor"]			=	"Disruptor",
	["npc_dota_hero_nyx_assassin"]		=	"Nyx Assassin",
	["npc_dota_hero_naga_siren"]		=	"Naga Siren",
	["npc_dota_hero_keeper_of_the_light"]=	"Keeper of the Light",
	["npc_dota_hero_visage"]			=	"Visage",
	["npc_dota_hero_wisp"]				=	"Io",
	["npc_dota_hero_slark"]				=	"Slark",
	["npc_dota_hero_medusa"]			=	"Medusa",
	["npc_dota_hero_troll_warlord"]		=	"Troll Warlord",
	["npc_dota_hero_centaur"]			=	"Centaur Warrunner",
	["npc_dota_hero_magnataur"]			=	"Magnus",
	["npc_dota_hero_shredder"]			=	"Timbersaw",
	["npc_dota_hero_bristleback"]		=	"Bristleback",
	["npc_dota_hero_tusk"]				=	"Tusk",
	["npc_dota_hero_skywrath_mage"]		=	"Skywrath Mage",
	["npc_dota_hero_abaddon"]			=	"Abaddon",
	["npc_dota_hero_elder_titan"]		=	"Elder Titan",
	["npc_dota_hero_legion_commander"]	=	"Legion Commander",
	["npc_dota_hero_ember_spirit"]		=	"Ember Spirit",
	["npc_dota_hero_earth_spirit"]		=	"Earth Spirit",
	["npc_dota_hero_abyssal_underlord"]	=	"Underlord",
	["npc_dota_hero_phoenix"]			=	"Phoenix",
	["npc_dota_hero_terrorblade"]		=	"Terrorblade",
	["npc_dota_hero_oracle"]			=	"Oracle",
	["npc_dota_hero_techies"]			=	"Techies",
	["npc_dota_hero_winter_wyvern"]		=	"Winter Wyvern",
	["npc_dota_hero_arc_warden"]		=	"Arc Warden",
	["npc_dota_hero_monkey_king"]		=	"Monkey King",
	["npc_dota_hero_pangolier"]			=	"Pangolier",
	["npc_dota_hero_dark_willow"]		=	"Dark Willow",
	["npc_dota_hero_grimstroke"]		=	"Grimstroke"]]--

if not BotSupportLib then
	BotSupportLib = class({})
end

function BotSupportLib:Init()
	print("[BotSupportLib] : Loading")
	LinkLuaModifier("modifier_bsl_execute_order_processor", "abilities/util/modifiers/modifier_bsl_execute_order_processor", LUA_MODIFIER_MOTION_NONE)
	LinkLuaModifier("modifier_bsl_eventhandler", "abilities/util/modifiers/modifier_bsl_eventhandler", LUA_MODIFIER_MOTION_NONE)
	LinkLuaModifier("modifier_bsl_thinker", "abilities/util/modifiers/modifier_bsl_thinker", LUA_MODIFIER_MOTION_NONE)
	LinkLuaModifier("modifier_bsl_disable_control", "abilities/util/modifiers/modifier_bsl_disable_control", LUA_MODIFIER_MOTION_NONE)
	LinkLuaModifier("modifier_vgmar_ward_container_observer", "abilities/util/modifiers/ward_containers", LUA_MODIFIER_MOTION_NONE)
	LinkLuaModifier("modifier_vgmar_ward_container_sentry", "abilities/util/modifiers/ward_containers", LUA_MODIFIER_MOTION_NONE)
	ListenToGameEvent( "dota_player_learned_ability", Dynamic_Wrap( BotSupportLib, "OnAbilityLearned" ), self)
	ListenToGameEvent( "npc_spawned", Dynamic_Wrap( BotSupportLib, "OnNPCSpawned" ), self)
	
	Convars:RegisterCommand('bsl_force_reset_eop', Dynamic_Wrap( BotSupportLib, "ForceResetAllEOPs" ), "Resets all EOPs", 0)
	Convars:RegisterCommand('bsl_draw_all_wardspots', Dynamic_Wrap( BotSupportLib, "DebugDrawAllWardSpots" ), "Draw All Wardspots Available", 0)
	Convars:RegisterCommand('bsl_draw_all_poi', Dynamic_Wrap( BotSupportLib, "DebugDrawAllPlaces" ), "Draw All Places of Interest Available", 0)
	Convars:RegisterConvar('bsl_debugdraw', "0", "Set to 1 to draw BotSupportLib debug info. Set to 0 to disable.", 0)

	self.botheroes = {}
	self.botdata = {}
	self.wards = {[2] = {observer = {}, sentry = {}}, [3] = {observer = {}, sentry = {}}}
	self.wardspottimestamp = {}
	self.forceattackorderprocessors = {}
	self.heroeswithinviscapabilities = {}
	self.sentrywardpurchasedata = {
		lastpurchasetime = 0,
		lastrestocktime = 0,
		idlepurchaseinterval = 30,
		wardsavailable = 10,
		maxwards = 10,
		desiredwardnum = 1 + math.bool(#BotSupportLib.heroeswithinviscapabilities>0) + math.bool(GameRules:GetDOTATime(false,false)>30*60)
	}
	self.midwardgiven = false
end

function BotSupportLib:ForceResetAllEOPs()
	local EOPs = {}
	for i,v in ipairs(HeroList:GetAllHeroes()) do
		for _,j in ipairs(v:FindAllModifiersByName("modifier_bsl_execute_order_processor")) do
			table.insert(EOPs, j)
		end
	end
	print("[BSL]::DEBUG:Resetting "..#EOPs.." Execute Order Processors")
	for _,j in ipairs(EOPs) do
		j:SetDuration(1,true)
	end
end

function BotSupportLib:DebugDraw()
	if Convars:GetInt("bsl_debugdraw") == 1 then
		return true
	end
	return false
end

local anti_np_abilities = {
	["npc_dota_hero_bloodseeker"] = {
		["bloodseeker_blood_bath"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_crystal_maiden"] = {
		["crystal_maiden_crystal_nova"] = {pt = true, range = -1, importance = 0},
		["crystal_maiden_freezing_field"] = {pt = false, range = 600, importance = 2}
	},
	["npc_dota_hero_drow_ranger"] = {
		["drow_ranger_wave_of_silence"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_earthshaker"] = {
		["earthshaker_fissure"] = {pt = true, range = -1, importance = 0},
		["earthshaker_enchant_totem"] = {pt = false, range = 250, importance = 0},
		["earthshaker_echo_slam"] = {pt = false, range = 550, importance = 2}
	},
	["npc_dota_hero_pudge"] = {
		["pudge_meat_hook"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_razor"] = {
		["razor_plasma_field"] = {pt = false, range = 650, importance = 0}
	},
	["npc_dota_hero_sand_king"] = {
		["sandking_burrowstrike"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_tiny"] = {
		["tiny_avalanche"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_vengefulspirit"] = {
		["vengefulspirit_wave_of_terror"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_windrunner"] = {
		["windrunner_powershot"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_zuus"] = {
		["zuus_lightning_bolt"] = {pt = true, range = -1, importance = 0},
		["zuus_cloud"] = {pt = true, range = -1, importance = 1},
		["zuus_thundergods_wrath"] = {pt = false, range = 999999, importance = 1}
	},
	["npc_dota_hero_kunkka"] = {
		["kunkka_torrent"] = {pt = true, range = -1, importance = 0},
		["kunkka_ghostship"] = {pt = true, range = -1, importance = 2}
	},
	["npc_dota_hero_lina"] = {
		["lina_light_strike_array"] = {pt = true, range = -1, importance = 0},
		["lina_dragon_slave"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_lion"] = {
		["lion_impale"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_tidehunter"] = {
		["tidehunter_anchor_smash"] = {pt = false, range = 350, importance = 0},
		["tidehunter_ravage"] = {pt = false, range = 700, importance = 2}
	},
	["npc_dota_hero_witch_doctor"] = {
		["witch_doctor_maledict"] = {pt = true, range = -1, importance = 1},
		["witch_doctor_death_ward"] = {pt = true, range = -1, importance = 2}
	},
	["npc_dota_hero_riki"] = {
		["riki_smoke_screen"] = {pt = true, range = -1, importance = 0},
		["riki_tricks_of_the_trade"] = {pt = false, range = 425, importance = 2}
	},
	["npc_dota_hero_sniper"] = {
		["sniper_shrapnel"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_necrolyte"] = {
		["necrolyte_death_pulse"] = {pt = false, range = 450, importance = 0}
	},
	["npc_dota_hero_warlock"] = {
		["warlock_rain_of_chaos"] = {pt = true, range = -1, importance = 2}
	},
	["npc_dota_hero_death_prophet"] = {
		["death_prophet_carrion_swarm"] = {pt = true, range = -1, importance = 0},
		["death_prophet_silence"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_viper"] = {
		["viper_nethertoxin"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_dragon_knight"] = {
		["dragon_knight_breathe_fire"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_jakiro"] = {
		["jakiro_ice_path"] = {pt = true, range = -1, importance = 0},
		["jakiro_macropyre"] = {pt = true, range = -1, importance = 2},
		["jakiro_dual_breath"] = {pt = true, range = -1, importance = 0}
	},
	["npc_dota_hero_bristleback"] = {
		["bristleback_quill_spray"] = {pt = false, range = 600, importance = 0}
	},
	["npc_dota_hero_skywrath_mage"] = {
		["skywrath_mage_mystic_flare"] = {pt = true, range = -1, importance = 1}
	}
}

--TODO:Add events to track for the event response system
--TODO:Add Think Functions
--logicthinker structure
--(thinkerid, fID, endfID, interval, timeout, startability)
local affectedheroeslist = {
	["npc_dota_hero_skeleton_king"] = {
		abilities = {
			"skeleton_king_hellfire_blast",
			"skeleton_king_vampiric_aura",
			"skeleton_king_mortal_strike",
			"skeleton_king_reincarnation"
		},
		trackedintrinsicmodifiers = {
			["skeleton_king_mortal_strike"] = {"modifier_skeleton_king_mortal_strike"}
		},
		logicthinkers = {
			{1, 1, nil, 2.0, nil, "skeleton_king_mortal_strike"},
			{2, 2, 3, 2.0, 600, "skeleton_king_vampiric_aura"}
		}
	},
	["npc_dota_hero_zuus"] = {
		abilities = {
			"zuus_arc_lightning",
			"zuus_lightning_bolt",
			"zuus_cloud",
			"zuus_thundergods_wrath"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_drow_ranger"] = {
		abilities = {
			"drow_ranger_frost_arrows",
			"drow_ranger_wave_of_silence",
			"drow_ranger_trueshot",
			"drow_ranger_marksmanship"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_tiny"] = {
		abilities = {
			"tiny_avalanche",
			"tiny_toss",
			"tiny_craggy_exterior",
			"tiny_grow",
			"tiny_toss_tree"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {
			{1, 4, nil, 4.0, nil, "tiny_craggy_exterior"}
		}
	},
	["npc_dota_hero_viper"] = {
		abilities = {
			"viper_poison_attack",
			"viper_nethertoxin",
			"viper_viper_strike"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_phantom_assassin"] = {
		abilities = {
			"phantom_assassin_stifling_dagger",
			"phantom_assassin_phantom_strike",
			"phantom_assassin_blur",
			"phantom_assassin_coup_de_grace"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_lich"] = {
		abilities = {
			"lich_frost_nova",
			"lich_frost_shield",
			"lich_sinister_gaze",
			"lich_chain_frost"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {
			{1, 5, nil, 1.0, nil, "lich_frost_shield"}
		}
	},
	["npc_dota_hero_sven"] = {
		abilities = {
			"sven_storm_bolt",
			"sven_great_cleave",
			"sven_warcry",
			"sven_gods_strength"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_necrolyte"] = {
		abilities = {
			"necrolyte_death_pulse",
			"necrolyte_sadist",
			"necrolyte_heartstopper_aura",
			"necrolyte_reapers_scythe"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_omniknight"] = {
		abilities = {
			"omniknight_purification",
			"omniknight_repel",
			"omniknight_degen_aura",
			"omniknight_guardian_angel"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {
			{1, 6, nil, 1.0, nil, "omniknight_guardian_angel"}
		}
	}
}

local invis_settings = {
	innate = {
		["npc_dota_hero_mirana"] = {startlvl = 6, abilityname = "mirana_invis", modifiername = "modifier_mirana_moonlight_shadow"},
		["npc_dota_hero_sand_king"] = {startlvl = 1, abilityname = "sandking_sand_storm", modifiername = "modifier_sandking_sand_storm"},
		["npc_dota_hero_windrunner"] = {startlvl = 20, abilityname = "windrunner_windrun", modifiername = "modifier_windrunner_windrun_invis"},
		["npc_dota_hero_riki"] = {startlvl = 1, abilityname = "riki_permanent_invisibility", modifiername = "modifier_riki_permanent_invisibility"},
		["npc_dota_hero_templar_assassin"] = {startlvl = 1, abilityname = "templar_assassin_meld", modifiername = "modifier_templar_assassin_meld"},
		["npc_dota_hero_clinkz"] = {startlvl = 1, abilityname = "clinkz_wind_walk", modifiername = "modifier_clinkz_wind_walk"},
		["npc_dota_hero_bounty_hunter"] = {startlvl = 1, abilityname = "bounty_hunter_wind_walk", modifiername = "modifier_bounty_hunter_wind_walk"},
		["npc_dota_hero_weaver"] = {startlvl = 1, abilityname = "weaver_shukuchi", modifiername = "modifier_weaver_shukuchi"},
		["npc_dota_hero_invoker"] = {startlvl = 2, abilityname = "invoker_ghost_walk", modifiername = "modifier_invoker_ghost_walk_self"},
		["npc_dota_hero_treant"] = {startlvl = 1, abilityname = "treant_natures_guise", modifiername = "modifier_treant_natures_guise_invis"},
		["npc_dota_hero_nyx_assassin"] = {startlvl = 6, abilityname = "nyx_assassin_vendetta", modifiername = "modifier_nyx_assassin_vendetta"}
	},
	generic_invis = {
		invis_modifiers = {
			["modifier_invisible"] = true,
			["modifier_item_invisibility_edge_windwalk"] = true,
			["modifier_item_silver_edge_windwalk"] = true,
			["modifier_glimmer_cape_fade"] = true,
			["modifier_shadow_amulet_fade"] = true
		}
	}
}

local wardingsettings = {
	placementdetectionchance = {visible = 100, notvisible = 25}
}

local linkenmods = {
	["modifier_item_sphere_target"] = 0,
	["modifier_antimage_counterspell"] = 0,
	["modifier_special_bonus_spell_block"] = 0,
	["modifier_vgmar_i_spellshield"] = 1,
	["modifier_item_lotus_orb_active"] = 0
}

--Generic checks
function BotSupportLib:IsHeroBotControlled(hero)
	if hero ~= nil then
		local heroplayerID = hero:GetPlayerID()
		if PlayerResource:IsValidPlayer(heroplayerID) and PlayerResource:GetConnectionState(heroplayerID) == 1 then
			return true
		end
	end
	return false
end

function BotSupportLib:IsHeroBSLSupported(hero)
	if hero ~= nil then
		if affectedheroeslist[hero:GetName()] ~= nil then
			return true
		end
	end
	return false
end

--Database Calls
function BotSupportLib:GetAbilityFromDB(hero, name)
	if hero and name then
		if self.botdata[hero:entindex()].abilities[name] ~= nil then
			return self.botdata[hero:entindex()].abilities[name]
		end
	end
	return nil
end

function BotSupportLib:GetModifierFromDB(hero, name)
	if hero and name then
		if self.botdata[hero:entindex()].modifiers[name] ~= nil then
			if self.botdata[hero:entindex()].modifiers[name][2] == -1 or self.botdata[hero:entindex()].modifiers[name][2] > GameRules:GetDOTATime(false, false) then
				return self.botdata[hero:entindex()].modifiers[name][1]
			end
		end
	end
	return nil
end

function BotSupportLib:AddModifierToDB(hero, name, duration, overwrite)
	if not self.botdata[hero:entindex()].modifiers[name] then
		local timestamp = -1
		if duration and duration ~= -1 then
			timestamp = GameRules:GetDOTATime(false, false) + duration
		else
			timestamp = -1
		end
		table.insert(self.botdata[hero:entindex()].modifiers, name)
		self.botdata[hero:entindex()].modifiers[name] = {hero:FindModifierByName(name), timestamp}
	elseif self.botdata[hero:entindex()].modifiers[name] and overwrite then
		local timestamp = -1
		if duration and duration ~= -1 then
			timestamp = GameRules:GetDOTATime(false, false) + duration
		else
			timestamp = -1
		end
		self.botdata[hero:entindex()].modifiers[name] = {hero:FindModifierByName(name), timestamp}
	end
end

--call this OnAllHeroesSpawned
function BotSupportLib:StartBotInit()
	local heroes = HeroList:GetAllHeroes()
	--Attach OnAbilityFullyCast Event Handler
	GameRules.VGMAR.radiantanc:AddNewModifier(GameRules.VGMAR.radiantanc, nil, "modifier_bsl_eventhandler", {})
	for i=1,HeroList:GetHeroCount() do
		if self:IsHeroBotControlled(heroes[i]) and heroes[i]:IsRealHero() then
			table.insert(self.botheroes, heroes[i])
		end
	end
	for k,v in ipairs(self.botheroes) do
		if self:IsHeroBSLSupported(v) then
			print("[BotSupportLib] :: Initiating "..HeroNamesLib:ConvertInternalToHeroName( v:GetName() ))
			self:InitBotHero(v)
		end
	end
	Timers:CreateTimer({
		endTime = 5,
		callback = function()
			BotSupportLib:GlobalBotThink()
			return 0.5
		end
	})
end

function BotSupportLib:InitBotHero(unit)
	if unit and unit:IsRealHero() then
		if not self.botdata[unit:entindex()] then
			local index = unit:entindex()
			local abilities = {}
			for k,v in ipairs(affectedheroeslist[unit:GetName()].abilities) do
				table.insert(abilities, v)
				print("[BSL]:Initializing "..v.." for "..unit:GetName())
				abilities[v] = unit:FindAbilityByName(v)
			end
			table.insert(self.botdata, index)
			self.botdata[index] = {hero = unit, name = unit:GetName(), abilities = abilities, modifiers = {}, thinkers = {}, abilitythinkers = {}}
			for i,j in ipairs(affectedheroeslist[unit:GetName()].logicthinkers) do
				local thinkerdata = affectedheroeslist[unit:GetName()].logicthinkers[i]
				self:AttachThinker(unit, thinkerdata[1], thinkerdata[2], thinkerdata[3], thinkerdata[6], thinkerdata[4], thinkerdata[5])
				print("[BSL]:--------------------------------------------------")
				print("[BSL]: Attached Thinker Modifier to "..HeroNamesLib:ConvertInternalToHeroName(unit:GetName()))
				print("[BSL]:Config for Thinker "..tostring(thinkerdata[1]))
				print("fID: "..tostring(thinkerdata[2]))
				print("endfID: "..tostring(thinkerdata[3]))
				print("Interval: "..tostring(thinkerdata[4]))
				print("Timeout: "..tostring(thinkerdata[5]))
				if thinkerdata[6] ~= nil and thinkerdata[6] ~= true then
					print("Ability: "..tostring(thinkerdata[6]))
				end
				print("[BSL]:--------------------------------------------------")
			end
		end
	end
end

--Condition Response
function BotSupportLib:GetAbilityCastManaConditions(hero, ability, addabilities, remainder)
	local manacost = ability:GetManaCost(-1)
	local mana = hero:GetMana()
	local manaregen = hero:GetManaRegen()
	if addabilities then
		for _,i in ipairs(addabilities) do
			if i:IsFullyCastable() then
				--print("[BSL]::ACMC: Manacost:"..i:GetName().."IsFullyCastable :+"..i:GetManaCost(-1))
				manacost = manacost + i:GetManaCost(-1)
			elseif i:GetCooldownTimeRemaining() < 10 and i:GetLevel() > 0 then
				if mana + (manaregen * i:GetCooldownTimeRemaining()) >= i:GetManaCost(-1) then
					--print("[BSL]::ACMC: Manacost:"..i:GetName().."Will be FullyCastable in "..i:GetCooldownTimeRemaining().." :+"..i:GetManaCost(-1))
					manacost = manacost + i:GetManaCost(-1)
				end
			end
		end
		--print("[BSL]::ACMC: Manacost after addabilities:"..manacost)
	end
	if remainder ~= nil then
		--print("[BSL]::ACMC: Remainder>Manacost:"..tostring((mana - manacost)/hero:GetMaxMana() >= remainder))
		return (mana - manacost)/hero:GetMaxMana() >= remainder
	end
	--print("[BSL]::ACMC: Manacost<Mana:"..tostring(manacost < mana))
	return manacost < mana
end

function BotSupportLib:GetAbilityCastConditions(hero, ability)
	if not ability then return false end
	if not ability:IsFullyCastable() then return false end
	if ability:IsHidden() then return false end
	if hero:IsChanneling() and ability ~= hero:GetCurrentActiveAbility() then return false end
	return true
end

--Generic AI functions
function BotSupportLib:GetLowestHealthEnemy(hero, range)
	local lowesthealthenemy = {99999999,nil}
	local enemies = FindUnitsInRadius(hero:GetTeamNumber(), hero:GetAbsOrigin(), nil, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, DOTA_UNIT_TARGET_FLAG_FOW_VISIBLE, FIND_CLOSEST, false)
	for _,enemy in ipairs(enemies) do
		if lowesthealthenemy[1] > enemy:GetHealth() and enemy:IsAlive() then
			lowesthealthenemy = {enemy:GetHealth(), enemy}
		end
	end
	if lowesthealthenemy[2] then
		return lowesthealthenemy[2]
	end
	return nil
end

function BotSupportLib:GetClosestEnemyHero(hero, range)
	local enemy = FindUnitsInRadius(hero:GetTeamNumber(), hero:GetAbsOrigin(), nil, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, DOTA_UNIT_TARGET_FLAG_FOW_VISIBLE, FIND_CLOSEST, false)
	if enemy[1] then
		return {enemy[1], (enemy[1]:GetAbsOrigin() - hero:GetAbsOrigin()):Length2D()}
	end
	return {nil, 9999999}
end

function BotSupportLib:IsBotSafe(hero)
	if hero then
		local enemy = BotSupportLib:GetClosestEnemyHero(hero, 1000)
		if (enemy[1] and hero:GetHealthPercent() > 80 and enemy[1]:GetHealthPercent() < math.mapl(enemy[2], 200, 800, hero:GetHealthPercent()*0.25, hero:GetHealthPercent())) or enemy[1] == nil then
			return true
		end
		return false
	end
	return nil
end

function BotSupportLib:IsPosSafeForHero(hero, pos)
	if hero then
		local enemy = FindUnitsInRadius(hero:GetTeamNumber(), pos, nil, 1000, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, DOTA_UNIT_TARGET_FLAG_FOW_VISIBLE, FIND_CLOSEST, false)
		if (enemy[1] and enemy[1]:GetHealthPercent() < math.mapl((enemy[1]:GetAbsOrigin() - pos):Length2D(), 200, 800, hero:GetHealthPercent()*0.25, hero:GetHealthPercent())) or enemy[1] == nil then
			return true
		end
		return false
	end
	return nil
end

function BotSupportLib:CheckReflectModifiers(unit)
	for i,v in pairs(linkenmods) do
		if unit:HasModifier(i) then
			local modifier = unit:FindModifierByName(i)
			if modifier:GetStackCount() >= v then
				return true
			end
		end
	end
	return false
end

function BotSupportLib:GetWardContainerCount( hero, wardtype )
	local ret = 0
	if hero then
		if not wardtype or (wardtype ~= 1 and wardtype ~= 2) then
			wardtype = 1
		end
		if wardtype == 1 then
			local container = hero.obscontainer
			if container then
				ret = container:GetStackCount()
			end
		else
			local container = hero.sentcontainer
			if container then
				ret = container:GetStackCount()
			end
		end
	end
	return ret
end

--[[[0] = "DOTA_UNIT_ORDER_NONE",
[1] = "DOTA_UNIT_ORDER_MOVE_TO_POSITION",
[2] = "DOTA_UNIT_ORDER_MOVE_TO_TARGET",
[3] = "DOTA_UNIT_ORDER_ATTACK_MOVE",
[4] = "DOTA_UNIT_ORDER_ATTACK_TARGET",
[5] = "DOTA_UNIT_ORDER_CAST_POSITION",
[6] = "DOTA_UNIT_ORDER_CAST_TARGET",
[7] = "DOTA_UNIT_ORDER_CAST_TARGET_TREE",
[8] = "DOTA_UNIT_ORDER_CAST_NO_TARGET", 
[9] = "DOTA_UNIT_ORDER_CAST_TOGGLE",
[10] = "DOTA_UNIT_ORDER_HOLD_POSITION",
[11] = "DOTA_UNIT_ORDER_TRAIN_ABILITY",
[12] = "DOTA_UNIT_ORDER_DROP_ITEM",
[13] = "DOTA_UNIT_ORDER_GIVE_ITEM",
[14] = "DOTA_UNIT_ORDER_PICKUP_ITEM",
[15] = "DOTA_UNIT_ORDER_PICKUP_RUNE",
[16] = "DOTA_UNIT_ORDER_PURCHASE_ITEM",
[17] = "DOTA_UNIT_ORDER_SELL_ITEM",
[18] = "DOTA_UNIT_ORDER_DISASSEMBLE_ITEM",
[19] = "DOTA_UNIT_ORDER_MOVE_ITEM",
[20] = "DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO",
[21] = "DOTA_UNIT_ORDER_STOP",
[22] = "DOTA_UNIT_ORDER_TAUNT",
[23] = "DOTA_UNIT_ORDER_BUYBACK",
[24] = "DOTA_UNIT_ORDER_GLYPH",
[25] = "DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH",
[26] = "DOTA_UNIT_ORDER_CAST_RUNE",
[27] = "DOTA_UNIT_ORDER_PING_ABILITY",
[28] = "DOTA_UNIT_ORDER_MOVE_TO_DIRECTION",
[29] = "DOTA_UNIT_ORDER_PATROL",
[30] = "DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION",
[31] = "DOTA_UNIT_ORDER_RADAR",
[32] = "DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK",
[33] = "DOTA_UNIT_ORDER_CONTINUE",
[34] = "DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED",
[35] = "DOTA_UNIT_ORDER_CAST_RIVER_PAINT"--]]

function BotSupportLib:CastAbility(hero, order_type, target, ability, position, queue, force, cancelondeath, interval, timeout)
	if hero then
		local tindex = nil
		local aindex = nil
		if target then
			if type(target) == "number" then
				tindex = target
			else
				tindex = target:entindex()
			end
		end
		if ability then
			if type(ability) == "number" then
				aindex = ability
				ability = EntIndexToHScript(aindex)
			else
				aindex = ability:entindex()
			end
			if ability:IsFullyCastable() then
				hero:AddNewModifier(hero, nil, "modifier_bsl_execute_order_processor", {
					ordertype = order_type,
					tindex = tindex,
					aindex = aindex,
					pos = position,
					queue = queue,
					force = force,
					cancelondeath = cancelondeath,
					timeout = timeout,
					interval = interval
				})
			end
		end
	end
end

function BotSupportLib:MoveToPosition(hero, position, queue, force, cancelondeath, interval, timeout)
	if hero then
		if position and GridNav:CanFindPath(hero:GetAbsOrigin(), position) then
			hero:AddNewModifier(hero, nil, "modifier_bsl_execute_order_processor", {
				ordertype = DOTA_UNIT_ORDER_MOVE_TO_POSITION,
				tindex = nil,
				aindex = nil,
				pos = position,
				queue = queue,
				force = force,
				cancelondeath = cancelondeath,
				timeout = timeout,
				interval = interval
			})
		end
	end
end

function BotSupportLib:AttackTarget(hero, target, position, queue, force, cancelondeath, interval, timeout)
	if hero then
		local tindex = nil
		local targetent = nil
		local order_type = nil
		if target then
			if type(target) == "number" then
				tindex = target
			else
				tindex = target:entindex()
			end
			if tindex ~= nil then
				local tent = EntIndexToHScript(tindex)
				if tent:GetTeamNumber() ~= hero:GetTeamNumber() or (tent:GetTeamNumber() == hero:GetTeamNumber() and tent:IsDeniable()) then
					if Extensions:IsVisibleToTeam(tent, hero:GetTeamNumber()) then
						targetent = true
					end
				end
			end
		end
		if position then
			order_type = DOTA_UNIT_ORDER_ATTACK_MOVE
		elseif targetent then
			order_type = DOTA_UNIT_ORDER_ATTACK_TARGET
		end
		if order_type ~= nil then
			local faop = hero:AddNewModifier(hero, nil, "modifier_bsl_execute_order_processor", {
				ordertype = order_type,
				tindex = tindex,
				pos = position,
				queue = queue,
				force = force,
				cancelondeath = cancelondeath,
				timeout = timeout,
				interval = interval
			})
			if BotSupportLib.forceattackorderprocessors[hero:entindex()] == nil then
				table.insert(BotSupportLib.forceattackorderprocessors, hero:entindex())
			else
				if not BotSupportLib.forceattackorderprocessors[hero:entindex()]:IsNull() then
					BotSupportLib.forceattackorderprocessors[hero:entindex()]:Destroy()
				end
			end
			if faop:IsNull() then
				BotSupportLib.forceattackorderprocessors[hero:entindex()] = nil
			else
				BotSupportLib.forceattackorderprocessors[hero:entindex()] = faop
			end
		end
	end
end

--Adding Intrinsic Modifiers Tracking
function BotSupportLib:OnAbilityLearned( keys )
	local player = EntIndexToHScript(keys.player)
	local abilityname = keys.abilityname
	local playerhero = nil
	
	local heroes = HeroList:GetAllHeroes()
	for i=1,#self.botheroes do
		if self.botheroes[i] and self.botheroes[i]:GetPlayerOwner() == player then
			playerhero = self.botheroes[i]
			break
		end
	end
	if playerhero and playerhero:FindAbilityByName(abilityname) then
		local index = playerhero:entindex()
		if self:IsHeroBSLSupported(playerhero) then
			if self.botdata[index] then
				for k,v in pairs(affectedheroeslist[playerhero:GetName()].trackedintrinsicmodifiers) do
					if abilityname == k then
						for _,j in ipairs(v) do
							if not self.botdata[index].modifiers[j] then
								self:AddModifierToDB(playerhero, j, -1)
							end
						end
					end
				end
				for i,j in pairs(self.botdata[index].abilitythinkers) do
					if abilityname == i then
						for _,n in ipairs(j) do
							if n and n:IsNull() == false then
								n:StartIntervalThinkWithPresetInterval()
							end
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:ClearConsumablesAndJunk(unit)
	local junk = {
		["item_tango"] = 20,
		["item_clarity"] = 20,
		["item_enchanted_mango"] = 10,
		["item_bottle"] = 30,
		["item_flask"] = 20,
		["item_magic_wand"] = 30,
		["item_quelling_blade"] = 40,
		["item_stout_shield"] = 50
	}
	if InvManager:GetHeroFreeInventorySlots( unit, true, true, false ) < 1 then
		for i = 0, 8 do
			local slotitem = unit:GetItemInSlot(i)
			if slotitem then
				if junk[slotitem:GetName()] and BotSupportLib:TimeIsLaterThan(junk[slotitem:GetName()], 0) then
					if slotitem:GetName() ~= "item_enchanted_mango" then
						local price = slotitem:GetCost()/2
						unit:ModifyGold(price, true, 0)
					end
					unit:RemoveItem(slotitem)
				end
			end
		end
	end
end

function BotSupportLib:AddWardAbility(hero, mode)
	if hero then
		local abilityname = 'item_ward_observer'
		if mode == 2 then
			abilityname = 'item_ward_sentry'
		end
		local ret = hero:FindAbilityByName(abilityname)
		if ret == nil then
			ret = hero:AddAbility(abilityname)
			ret:SetHidden(true)
		end
		return ret
	end
	return nil
end

function BotSupportLib:PlaceWard(hero, mode, pos)
	if hero then
		if (mode == 1 and BotSupportLib:GetWardContainerCount(hero, 1) > 0) or (mode == 2 and BotSupportLib:GetWardContainerCount(hero, 2) > 0) then
			hero:SetCursorPosition(pos)
			if BotSupportLib:DebugDraw() then
				DebugDrawBox(pos, Vector(-5, -5, 0), Vector(5, 5, 0), 255, 255, 0, 180, 2)
				DebugDrawBox(hero:GetAbsOrigin(), Vector(-5, -5, 0), Vector(5, 5, 0), 255, 255, 0, 180, 2)
				DebugDrawLine(hero:GetAbsOrigin(), pos, 0, 255, 0, true, 2)
				if mode == 1 then
					DebugDrawCircle(pos, Vector(255, 255, 0), 60, KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_observer'), 'vision_range'), true, 2)
				elseif mode == 2 then
					DebugDrawCircle(pos, Vector(80, 80, 255), 60, KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_sentry'), 'true_sight_range'), true, 2)
				end
			end
			if mode == 1 then
				if hero.obsability:IsNull() then
					hero.obsability = BotSupportLib:AddWardAbility(hero, 1)
				end
				hero:MoveToPosition(pos)
				hero.obsability:OnSpellStart()
				hero.obscontainer:DecrementStackCount()
			elseif mode == 2 then
				if hero.sentability:IsNull() then
					hero.sentability = BotSupportLib:AddWardAbility(hero, 2)
				end
				hero:MoveToPosition(pos)
				hero.sentability:OnSpellStart()
				hero.sentcontainer:DecrementStackCount()
			end
		end
	end
end

function BotSupportLib:GlobalBotThink()
	if GameRules:State_Get() >= DOTA_GAMERULES_STATE_PRE_GAME then
		--////////////////////
		--Clearing Ward Table
		--////////////////////
		--Radiant Wards
		for _, wardtype in pairs(BotSupportLib.wards[2]) do
			for num, wardn in pairs(wardtype) do
				if type(wardn) == 'number' then
					local wardentry = wardtype[wardn]
					if wardentry and wardentry.ward then
						--[[if not wardentry.ward:IsNull() then
							print('[BSL]Ward DB: Radiant Entry#: '..num..' | entindex: '..wardentry.ward:entindex()..', IsAlive(): '..tostring(wardentry.ward:IsAlive())..', remaining time: '..tostring((wardentry.timestamp + KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_observer'), 'lifetime')) - GameRules:GetDOTATime(false, false)))
						end--]]
						if wardentry.ward:IsNull() or wardentry.ward:IsAlive() == false or wardentry.timestamp + KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_observer'), 'lifetime') < GameRules:GetDOTATime(false, false) then
							table.remove(wardtype, num)
							--print('removed ward #'..num..' from the ward database')
						end
					end
				end
			end
		end
		--Dire Wards
		for _, wardtype in pairs(BotSupportLib.wards[3]) do
			for num, wardn in pairs(wardtype) do
				if type(wardn) == 'number' then
					local wardentry = wardtype[wardn]
					if wardentry and wardentry.ward then
						--[[if not wardentry.ward:IsNull() then
							print('[BSL]Ward DB: Dire Entry#: '..num..' | entindex: '..wardentry.ward:entindex()..', IsAlive(): '..tostring(wardentry.ward:IsAlive())..', remaining time: '..tostring((wardentry.timestamp + KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_observer'), 'lifetime')) - GameRules:GetDOTATime(false, false)))
						end--]]
						if wardentry.ward:IsNull() or wardentry.ward:IsAlive() == false or wardentry.timestamp + KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_observer'), 'lifetime') < GameRules:GetDOTATime(false, false) then
							table.remove(wardtype, num)
							--print('removed ward #'..num..' from the ward database')
						end
					end
				end
			end
		end
		--///////////////////////
		--Dire Courier AutoReturn
		--///////////////////////
		for _, c in ipairs(Entities:FindAllByClassname("npc_dota_courier")) do
			if c:GetTeamNumber() == DOTA_TEAM_BADGUYS then
				if c:IsAlive() and c:IsIdle() and not (Extensions:isPointInsidePolygon(c:GetAbsOrigin(), Extensions.locations.fountains.Dire) or Extensions:isPointInsidePolygon(c:GetAbsOrigin(), Extensions.locations.secretshops.Dire)) then
					local courabilityname = nil
					local courability = nil
					local itemsoncour = false
					for i=1,8 do
						if c:GetItemInSlot(i) ~= nil then
							itemsoncour = true
							break
						end
					end
					if itemsoncour then
						courabilityname = "courier_return_stash_items"
					else
						courabilityname = "courier_return_to_base"
					end
					courability = c:FindAbilityByName(courabilityname)
					if courability then
						courability:CastAbility()
					end
				end
				break
			end
		end
		--Parse Radiant Heroes for innate invisibility conditions
		for _, h in ipairs(GameRules.VGMAR.radiantheroes) do
			if invis_settings.innate[h:GetName()] then
				local heroinvisdata = invis_settings.innate[h:GetName()]
				if h:GetLevel() >= heroinvisdata.startlvl then
					if BotSupportLib.heroeswithinviscapabilities[h:GetName()] == nil then
						table.insert(BotSupportLib.heroeswithinviscapabilities, h:GetName())
					end
					BotSupportLib.heroeswithinviscapabilities[h:GetName()] = true
				end
			end
		end
		local heroes = HeroList:GetAllHeroes()
		for i=0,HeroList:GetHeroCount() do
			local heroent = heroes[i]
			if heroent then
				if BotSupportLib:IsHeroBotControlled(heroent) then
					--////////////////////
					-- Courier Call Check
					--////////////////////
					local itemcostthreshold = math.mapl(GameRules:GetDOTATime(false, false), 0, 90*60, 100, 500)
					if BotRolesLib:HeroIsASupport(heroent) then
						itemcostthreshold = itemcostthreshold * 1.2
					end
					if GameRules:State_Get() >= DOTA_GAMERULES_STATE_PRE_GAME and InvManager:GetHeroInventoryItemsCost( heroent, false, false, true ) > itemcostthreshold then
						local cour = GameRules.VGMAR:GetHerosCourier(heroent)
						if cour then
							local fountainpoly = Extensions.locations.fountains.Dire
							if heroent:GetTeamNumber() == 2 then
								fountainpoly = Extensions.locations.fountains.Radiant
							end
							if Extensions:isPointInsidePolygon(cour:GetAbsOrigin(), fountainpoly) and not Extensions:isPointInsidePolygon(heroent:GetAbsOrigin(), fountainpoly) then
								local couriercallability = cour:FindAbilityByName("courier_take_stash_and_transfer_items")
								if cour:IsAlive() and couriercallability then
									local itemsnum = InvManager:GetHeroInventoryItemsNum( heroent, true, false, false, true )
									if InvManager:GetHeroFreeInventorySlots(heroent, true, true, false) >= itemsnum then
										cour:CastAbilityNoTarget(couriercallability, heroent:GetPlayerOwnerID())
									end
								end
							end
						end
					end
					--/////////////////////////////////
					--Transform Ward Item into modifier
					--/////////////////////////////////
					heroent.obscontainer = heroent.obscontainer or heroent:AddNewModifier(heroent, nil, "modifier_vgmar_ward_container_observer", {})
					heroent.sentcontainer = heroent.sentcontainer or heroent:AddNewModifier(heroent, nil, "modifier_vgmar_ward_container_sentry", {})
					heroent.obsability = heroent.obsability or BotSupportLib:AddWardAbility(heroent, 1)
					heroent.sentability = heroent.sentability or BotSupportLib:AddWardAbility(heroent, 2)
					local obsw = InvManager:GetItemFromInventoryByName( heroent, "item_ward_observer", true, true, false )
					local sentw = InvManager:GetItemFromInventoryByName( heroent, "item_bot_sentry", true, true, false )
					if obsw then
						heroent.obscontainer:SetStackCount(heroent.obscontainer:GetStackCount() + obsw:GetCurrentCharges())
						heroent:RemoveItem(obsw)
					end
					if sentw then
						heroent.sentcontainer:SetStackCount(heroent.sentcontainer:GetStackCount() + sentw:GetCurrentCharges())
						heroent:RemoveItem(sentw)
					end
					--/////////////////////////////////
					--Sentry Purchase System
					--/////////////////////////////////
					if GameRules:State_Get() >= DOTA_GAMERULES_STATE_PRE_GAME and self.sentrywardpurchasedata.wardsavailable > 0 then
						--Purchase
						if BotRolesLib.DBReady and BotRolesLib:HeroIsASupport(heroent) then
							if BotSupportLib:DebugDraw() then
								if math.round(GameRules:GetDOTATime(false, false) % 2) == 0 then
									Extensions:AddEntText(heroent:entindex(), ' sentry wards '..BotSupportLib:GetWardContainerCount(heroent, 2) + InvManager:CountUsableItemChargesInHeroInventory( heroent, 'item_bot_sentry', true, true, true ) + InvManager:CountUsableItemChargesInHeroInventory(GameRules.VGMAR:GetHerosCourier(heroent), 'item_bot_sentry', true, true, false)..' | Desired: '..self.sentrywardpurchasedata.desiredwardnum, 2)
									Extensions:AddEntText(heroent:entindex(), 'swcontainer: '..BotSupportLib:GetWardContainerCount(heroent, 2)..', inventory: '..InvManager:CountUsableItemChargesInHeroInventory( heroent, 'item_bot_sentry', true, true, true )..', courier: '..InvManager:CountUsableItemChargesInHeroInventory(GameRules.VGMAR:GetHerosCourier(heroent), 'item_bot_sentry', true, true, false), 2)
								end
							end
							if heroent:GetGold() >= KeyValuesManager:GetItemPrice('item_bot_sentry') and self.sentrywardpurchasedata.lastpurchasetime + self.sentrywardpurchasedata.idlepurchaseinterval < GameRules:GetDOTATime(false, false) then
								if BotSupportLib:GetWardContainerCount(heroent, 2) + InvManager:CountUsableItemChargesInHeroInventory( heroent, 'item_bot_sentry', true, true, true ) + InvManager:CountUsableItemChargesInHeroInventory(GameRules.VGMAR:GetHerosCourier(heroent), 'item_bot_sentry', true, true, false) < self.sentrywardpurchasedata.desiredwardnum then
									local purchase = Extensions:SimulateItemPurchase(heroent, 'item_bot_sentry')
									if purchase then
										self.sentrywardpurchasedata.lastpurchasetime = GameRules:GetDOTATime(false, false)
										self.sentrywardpurchasedata.wardsavailable = self.sentrywardpurchasedata.wardsavailable - 1
										print(heroent:GetName()..' purchased a sentry ward. Wards remaining: '..self.sentrywardpurchasedata.wardsavailable)
									end
								end
							end
						end
						--Restock
						if self.sentrywardpurchasedata.lastrestocktime + KeyValuesManager:GetItemKV('item_ward_sentry').ItemStockTime < GameRules:GetDOTATime(false,false) then
							self.sentrywardpurchasedata.lastrestocktime = GameRules:GetDOTATime(false,false)
							if self.sentrywardpurchasedata.wardsavailable < self.sentrywardpurchasedata.maxwards then
								self.sentrywardpurchasedata.wardsavailable = self.sentrywardpurchasedata.wardsavailable + 1
							end
						end
					end
					--/////////////////////////////////
					-- Dust Purchase System
					--/////////////////////////////////
					if GameRules:State_Get() >= DOTA_GAMERULES_STATE_PRE_GAME and #BotSupportLib.heroeswithinviscapabilities > 0 then
						if BotRolesLib.DBReady and BotRolesLib:HeroIsASupport(heroent) then
							if InvManager:GetHeroFreeInventorySlots(heroent, true, false, false) > 0 and heroent:GetGold() >= KeyValuesManager:GetItemPrice('item_dust') then
								if InvManager:CountUsableItemChargesInHeroInventory( heroent, 'item_dust', true, true, true ) + InvManager:CountUsableItemChargesInHeroInventory(GameRules.VGMAR:GetHerosCourier(heroent), 'item_dust', true, true, false) < 1 then
									local purchase = Extensions:SimulateItemPurchase(heroent, 'item_dust')
									if purchase then
										print(heroent:GetName()..' purchased a dust')
									end
								end
							end
						end
					end
					--/////////////////////////////////
					-- Give Mid Ward
					--/////////////////////////////////
					if GameRules:State_Get() == DOTA_GAMERULES_STATE_PRE_GAME and BotRolesLib.DBReady and BotSupportLib:GetWardContainerCount(heroent, 1) > 1 then
						local midlaner = BotRolesLib:GetMidLaner()
						if midlaner then
							if BotSupportLib:GetWardContainerCount(midlaner, 1) < 1 then
								--print(heroent:GetName()..' giving a ward to '..midlaner:GetName())
								self.midwardgiven = true
								heroent.obscontainer:DecrementStackCount()
								midlaner.obscontainer:IncrementStackCount()
							end
						end
					end
					--/////////////////////////////////
					-- Dividing the wards
					--/////////////////////////////////
					if self.midwardgiven then
						local obsheroes, sentheroes = {}, {}
						for _, h in pairs(HeroList:GetAllHeroes()) do
							if BotSupportLib:IsHeroBotControlled(h) then
								if (h:GetAbsOrigin() - heroent:GetAbsOrigin()):Length2D() < KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_sentry'), 'tooltip_range') * 2 then
									if h:GetTeamNumber() == heroent:GetTeamNumber() then
										if h:GetName() ~= heroent:GetName() then
											if BotRolesLib:HeroIsASupport(h:GetName()) then
												if BotSupportLib:GetWardContainerCount(heroent, 1) > 1 and BotSupportLib:GetWardContainerCount(h, 1) < 1 then
													table.insert(obsheroes, h)
												end
												if BotSupportLib:GetWardContainerCount(heroent, 2) > 1 and BotSupportLib:GetWardContainerCount(h, 2) < 1 then
													table.insert(sentheroes, h)
												end
											end
										end
									end
								end
							end
						end
						if #obsheroes > 0 then
							local obsh = table.random(obsheroes)
							heroent.obscontainer:DecrementStackCount()
							obsh.obscontainer:IncrementStackCount()
						end
						if #sentheroes > 0 then
							local senth = table.random(sentheroes)
							heroent.sentcontainer:DecrementStackCount()
							senth.sentcontainer:IncrementStackCount()
						end
					end
					--////////////////////
					--Warding
					--////////////////////
					if BotSupportLib:GetClosestEnemyHero(heroent, 1000)[1] == nil and heroent:IsAlive() and heroent:IsRealHero() and heroent:FindModifierByName("modifier_bsl_execute_order_processor") == nil and not heroent:IsChanneling() then
						--local obswarditem = InvManager:GetItemFromInventoryByName( heroent, "item_ward_observer", false, false, false )
						--local sentwarditem = InvManager:GetItemFromInventoryByName( heroent, "item_ward_sentry", false, false, false )
						if BotSupportLib:GetWardContainerCount(heroent, 1) > 0 then
							local wardspot = BotSupportLib:FindValidNearbyWardSpot(heroent, 1)
							if wardspot and wardspot[1] then
								heroent.wardspot = wardspot[2]
								if (wardspot[1] - heroent:GetAbsOrigin()):Length2D() > KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV("item_ward_observer"), "tooltip_range") then
									local wardplacespot = wardspot[1] - ((wardspot[1]-heroent:GetAbsOrigin()):Normalized() * (KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV("item_ward_observer"), "tooltip_range") * 0.8))
									if BotSupportLib:DebugDraw() then
										DebugDrawLine(heroent:GetAbsOrigin(), wardplacespot, 255, 255, 0, true, 1)
										DebugDrawLine(wardplacespot, wardspot[1], 128, 255, 0, true, 1)
										DebugDrawBox(wardplacespot, Vector(-5, -5, 0), Vector(5, 5, 0), 255, 255, 0, 180, 1)
										DebugDrawBox(wardspot[1], Vector(-5, -5, 0), Vector(5, 5, 0), 128, 255, 0, 180, 1)
									end
									self:MoveToPosition(heroent, wardplacespot, false, true, true, 0.05)
								else
									heroent.wardpos = wardspot[1]
									BotSupportLib:PlaceWard(heroent, 1, wardspot[1])
								end
							end
						end
						if heroent:FindModifierByName("modifier_bsl_execute_order_processor") == nil and BotSupportLib:GetWardContainerCount(heroent, 2) > 0 then
							local wardspot = BotSupportLib:FindValidNearbyWardSpot(heroent, 2)
							if wardspot and wardspot[1] then
								print(heroent:GetName()..' Found a Sentry Ward Spot '..tostring(wardspot[2]))
								heroent.wardspot = wardspot[2]
								if (wardspot[1] - heroent:GetAbsOrigin()):Length2D() > KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV("item_ward_sentry"), "tooltip_range") then
									local wardplacespot = wardspot[1] - ((wardspot[1]-heroent:GetAbsOrigin()):Normalized() * (KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV("item_ward_sentry"), "tooltip_range") * 0.8))
									if BotSupportLib:DebugDraw() then
										DebugDrawLine(heroent:GetAbsOrigin(), wardplacespot, 255, 255, 0, true, 2)
										DebugDrawLine(wardplacespot, wardspot[1], 128, 255, 0, true, 2)
										DebugDrawBox(wardplacespot, Vector(-5, -5, 0), Vector(5, 5, 0), 255, 255, 0, 180, 2)
										DebugDrawBox(wardspot[1], Vector(-5, -5, 0), Vector(5, 5, 0), 128, 255, 0, 180, 2)
									end
									self:MoveToPosition(heroent, wardplacespot, false, true, true, 0.05)
								else
									heroent.wardpos = wardspot[1]
									BotSupportLib:PlaceWard(heroent, 2, wardspot[1])
								end
								--BotSupportLib:CastAbility(heroent, DOTA_UNIT_ORDER_CAST_POSITION, nil, heroent.sentability, wardspot[1], false, true, true)
							end
						end
					end
					--////////////////////
					--Break Enemy Wards
					--////////////////////
					local closestenemyward = BotSupportLib:GetClosestVisibleEnemyWardInRange(heroent, heroent:GetCurrentVisionRange())
					if closestenemyward and heroent:IsAlive() and not heroent:IsChanneling() then
						local wardtoherodir = (closestenemyward:GetAbsOrigin() - heroent:GetAbsOrigin()):Normalized()
						local dist = Extensions:GetUnitDistance(closestenemyward, heroent)
						if heroent:Script_GetAttackRange() < dist then
							dist = heroent:Script_GetAttackRange()
						end
						local closestattackposition = closestenemyward:GetAbsOrigin() - wardtoherodir*dist
						if BotSupportLib:DebugDraw() then
							DebugDrawBox(closestenemyward:GetAbsOrigin(), Vector(-5, -5, 0), Vector(5, 5, 0), 255, 255, 0, 180, 2)
							DebugDrawLine(heroent:GetAbsOrigin(), closestenemyward:GetAbsOrigin(), 255, 255, 255, true, 2)
						end
						local tango = nil
						if InvManager:HeroHasUsableItemInInventory(heroent, "item_tango", false, false, false) then
							tango = InvManager:GetItemFromInventoryByName(heroent, "item_tango", false, false, false)
						end
						local quellingblade = nil
						if InvManager:HeroHasUsableItemInInventory(heroent, "item_quelling_blade", false, false, false) then
							quellingblade = InvManager:GetItemFromInventoryByName(heroent, "item_quelling_blade", false, false, false)
						end
						if BotSupportLib:IsBotSafe(heroent) then
							if tango ~= nil and tango:IsFullyCastable() and heroent:GetHealthPercent() < 90 then
								BotSupportLib:CastAbility(heroent, DOTA_UNIT_ORDER_CAST_TARGET, closestenemyward, tango, nil, false, true, true, 0.5, 2)
							elseif quellingblade ~= nil and quellingblade:IsFullyCastable() then
								BotSupportLib:CastAbility(heroent, DOTA_UNIT_ORDER_CAST_TARGET, closestenemyward, quellingblade, nil, false, true, true, 0.5, 2)
							else
								if BotSupportLib:IsPosSafeForHero(heroent, closestattackposition) then
									if BotSupportLib:DebugDraw() then
										DebugDrawBox(closestattackposition, Vector(-5, -5, 0), Vector(5, 5, 0), 0, 255, 0, 180, 2)
										DebugDrawLine(closestattackposition, closestenemyward:GetAbsOrigin(), 0, 255, 0, true, 2)
									end
									if heroent:GetAttackTarget() ~= closestenemyward then
										BotSupportLib:AttackTarget(heroent, closestenemyward, nil, false, false, true, 0.1, 1.5)
									end
								else
									if BotSupportLib:DebugDraw() then
										DebugDrawBox(closestattackposition, Vector(-3, -3, 0), Vector(3, 3, 0), 255, 0, 0, 180, 2)
									end
								end
							end
						else
							if BotSupportLib:DebugDraw() then
								DebugDrawBox(heroent:GetAbsOrigin(), Vector(-3, -3, 0), Vector(3, 3, 0), 255, 0, 0, 180, 2)
							end
						end
					end
					--////////////////////
					--Junk Disposal
					--////////////////////
					if GameRules:State_Get() == DOTA_GAMERULES_STATE_GAME_IN_PROGRESS and heroent:IsRealHero() then
						BotSupportLib:ClearConsumablesAndJunk(heroent)
					end
					--////////////////////
					--Bot Bloodstone Usage
					--////////////////////
					if heroent:IsRealHero() and InvManager:HeroHasUsableItemInInventory( heroent, "item_bloodstone", false, false, false ) and heroent:IsAlive() then
						local bloodstone = InvManager:GetItemFromInventoryByName( heroent, "item_bloodstone", false, false, false )
						if bloodstone ~= nil and bloodstone:IsFullyCastable() and heroent:GetHealth()/heroent:GetMaxHealth() < 0.3 and heroent:GetMana()/heroent:GetMaxMana() > 0.6 then
							BotSupportLib:CastAbility(heroent, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, bloodstone, nil, false, true, true)
						end
					end
					--///////////////////////////////////
					--Butterfly Replacement(thx Valve /s)
					--///////////////////////////////////
					if heroent:IsRealHero() and InvManager:HeroHasUsableItemInInventory( heroent, "item_butterfly", false, false, false ) then
						local bfly = InvManager:GetItemFromInventoryByName( heroent, "item_butterfly", false, true, true )
						if bfly then
							InvManager:RemoveNItemsInInventory(heroent, "item_butterfly", 1)
							heroent:AddItemByName("item_butterfly_fixed")
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:Event_ModifierApplied(parent, caster, modifiername, ability)
	--Check Modifier Name agains invis modifiers
	--Check previous visibility
	--Use Dust, Place Sentry
	if invis_settings.generic_invis.invis_modifiers[modifiername] then
		if parent:GetTeamNumber() == DOTA_TEAM_GOODGUYS then
			if Extensions:IsPositionFoWVisible(parent:GetAbsOrigin(), BotSupportLib:GetClosestEnemyHero(parent, 3000)[1]) then
				for _, bot in ipairs(FindUnitsInRadius(parent:GetTeamNumber(), parent:GetAbsOrigin(), nil, 1500, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, DOTA_UNIT_TARGET_FLAG_NONE, FIND_CLOSEST, false)) do
					if BotSupportLib:IsHeroBotControlled(bot) and bot:IsRealHero() then
						--Dust Usage
						if InvManager:HeroHasReadyItemInInventory( bot, 'item_dust', false, false, false ) and Extensions:GetUnitDistance(parent, bot) < KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_dust'), 'radius') then
							local dust = InvManager:GetItemFromInventoryByName( bot, 'item_dust', false, false, false )
							if dust ~= nil and dust:IsFullyCastable() then
								BotSupportLib:CastAbility(bot, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, dust, nil, false, true, true)
								break
							end
						end
						--Sentry Usage
						if BotSupportLib:GetWardContainerCount(bot, 2) > 0 and BotSupportLib:CheckNoWardNearbyCoord(bot:GetTeamNumber(), bot:GetAbsOrigin(), KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_sentry'), 'true_sight_range'))[2] then
							BotSupportLib:PlaceWard(bot, 2, (bot:GetAbsOrigin() + (Extensions:GetUtoTDirectionVector(bot, parent) * (Extensions:GetUnitDistance(bot, parent) / 2))))
							break
						end
					end
				end
				--Updating the Invis Capable Unit List
				if BotSupportLib.heroeswithinviscapabilities[parent:GetName()] == nil then
					table.insert(BotSupportLib.heroeswithinviscapabilities, parent:GetName())
				end
				BotSupportLib.heroeswithinviscapabilities[parent:GetName()] = true	
			end
		end
	end
end

--Events triggered by bsl_eventhandler
function BotSupportLib:OnAttackLanded(attacker, target, event)
	if event and attacker and target then
		local index = attacker:entindex()
		if self:IsHeroBSLSupported(attacker) then
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				if target:IsRealUnit(true) then
					if name == "npc_dota_hero_drow_ranger" then
						local ultimate = self:GetAbilityFromDB(attacker, "drow_ranger_marksmanship")
						local precisionaura = self:GetAbilityFromDB(attacker, "drow_ranger_trueshot")
						if target:IsBuilding() then
							if ultimate:GetLevel() > 0 and self:GetAbilityCastConditions(attacker, precisionaura) then
								self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, precisionaura, nil, false, true, true)
							end
						end
					elseif name == "npc_dota_hero_skeleton_king" then
						local crit = self:GetAbilityFromDB(attacker, "skeleton_king_mortal_strike")
						local reincarnation = self:GetAbilityFromDB(attacker, "skeleton_king_reincarnation")
						local skeletonsmodifier = self:GetModifierFromDB(attacker, "modifier_skeleton_king_mortal_strike")
						if target and (target:IsNeutralUnitType() or target:IsBuilding()) then
							if self:GetAbilityCastConditions(attacker, crit) and self:GetAbilityCastManaConditions(attacker, crit, {reincarnation}, 0.5) then
								if skeletonsmodifier and skeletonsmodifier:GetStackCount() >= crit:GetSpecialValueFor("max_skeleton_charges") then
									self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, crit, nil, false, true, true)
								end
							end
						end
					elseif name == "npc_dota_hero_lich" then
						local gaze = self:GetAbilityFromDB(attacker, "lich_sinister_gaze")
						local ultimate = self:GetAbilityFromDB(attacker, "lich_chain_frost")
						if target and target:IsHero() then
							if self:GetAbilityCastConditions(attacker, gaze) and self:GetAbilityCastManaConditions(attacker, gaze, {ultimate}, 0.3) then
								self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_TARGET, target, gaze, nil, false, true, true, 0.5, 2)
							end
						end
					elseif name == "npc_dota_hero_viper" then
						local nethertoxin = self:GetAbilityFromDB(attacker, "viper_nethertoxin")
						if target and target:IsHero() then
							if self:GetAbilityCastConditions(attacker, nethertoxin) and self:GetAbilityCastManaConditions(attacker, nethertoxin, {}, 0.1) then
								if target:FindModifierByName("modifier_viper_nethertoxin") == nil then
									self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_POSITION, nil, nethertoxin, (target:GetAbsOrigin() + target:GetVelocity()), false, true, true)
								end
							end
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:OnAttackStart(attacker, target, event)
	if event and attacker and target then
		local index = attacker:entindex()
		if self:IsHeroBSLSupported(attacker) then
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				if name == "npc_dota_hero_sniper" then
					if target:IsHero() then
						local takeaim = self:GetAbilityFromDB(attacker, "sniper_take_aim")
						if self:GetAbilityCastConditions(attacker, takeaim) then
							self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, takeaim, nil, false, true, true)
						end
					end
				elseif name == "npc_dota_hero_necrolyte" then
					local shroud = self:GetAbilityFromDB(attacker, "necrolyte_sadist")
					local ultimate = self:GetAbilityFromDB(attacker, "necrolyte_reapers_scythe")
					if target:IsHero() then
						if self:GetAbilityCastConditions(attacker, ultimate) and self:GetAbilityCastManaConditions(attacker, ultimate, {shroud}, 0.1) then
							if (target:GetHealth() < (target:GetHealthDeficit()*ultimate:GetSpecialValueFor("damage_per_health"))*0.75) and target:IsMagicImmune() == false then
								if target:IsRealHero() then
									self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_TARGET, target, ultimate, nil, false, true, true, 0.2, 2)
								elseif target:IsHero() and math.random(1, 100) <= 25 then
									self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_TARGET, target, ultimate, nil, false, true, true, 0.2, 2)
								end
							end
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:OnNPCSpawned(event)
	local spawnedUnit = EntIndexToHScript(event.entindex)
	if spawnedUnit then
		if spawnedUnit:GetClassname() == "npc_dota_ward_base" or spawnedUnit:GetClassname() == "npc_dota_ward_base_truesight" then
			local warder = spawnedUnit:GetOwner():GetAssignedHero()
			--TODO: Currently Disabled bot placed wards from being recorded to DB
			if (warder and not BotSupportLib:IsHeroBotControlled(warder)) or (warder and spawnedUnit:GetClassname() == "npc_dota_ward_base") then
				if BotSupportLib:WardPosIsNotInIgnored(warder, warder.wardpos) then
					if spawnedUnit:GetClassname() == "npc_dota_ward_base" then
						BotSupportLib:OnWardPlaced(spawnedUnit, warder, "observer")
					elseif spawnedUnit:GetClassname() == "npc_dota_ward_base_truesight" then
						BotSupportLib:OnWardPlaced(spawnedUnit, warder, "sentry")
					end
				end
			end
		end
	end
end

function BotSupportLib:CheckNoWardNearby(team, polygons)
	local obsstatus = true
	local sentstatus = true
	for _, polygon in ipairs(polygons) do
		for _,ward in ipairs (Entities:FindAllByClassnameWithin("npc_dota_ward_base", Extensions:getPolygonMidPoint(polygon), Extensions:getPolygonMaxDistancePoint(polygon))) do 
			if Extensions:isPointInsidePolygon(ward:GetAbsOrigin(), polygon) and (ward:GetTeamNumber() == team) then
				obsstatus = false
			end
		end
		for _,ward in ipairs (Entities:FindAllByClassnameWithin("npc_dota_ward_base_truesight", Extensions:getPolygonMidPoint(polygon), Extensions:getPolygonMaxDistancePoint(polygon))) do
			if Extensions:isPointInsidePolygon(ward:GetAbsOrigin(), polygon) and (ward:GetTeamNumber() == team) then
				sentstatus = false
			end
		end
	end
	return {obsstatus, sentstatus}
end

function BotSupportLib:CheckNoWardNearbyCoord(team, posvector, maxrange)
	local obsstatus = true
	local sentstatus = true
	for _,ward in ipairs (Entities:FindAllByClassnameWithin("npc_dota_ward_base", posvector, maxrange)) do
		if ward:IsAlive() and (ward:GetTeamNumber() == team) then
			obsstatus = false
		end
	end
	for _,ward in ipairs (Entities:FindAllByClassnameWithin("npc_dota_ward_base_truesight", posvector, maxrange)) do
		if ward:IsAlive() and (ward:GetTeamNumber() == team) then
			sentstatus = false
		end
	end
	return {obsstatus, sentstatus}
end

--TODO: Fill spawn camps, Ward Spots
local places = {
	DireBase = {
		[1] = Vector(3040, 6943, 384), [2] = Vector(6048, 6624, 384),
		[3] = Vector(7008, 6752, 512), [4] = Vector(7577, 6238, 512),
		[5] = Vector(7200, 5344, 384), [6] = Vector(7454, 2525, 384),
		[7] = Vector(5401, 2648, 384), [8] = Vector(4704, 2912, 384),
		[9] = Vector(3325, 4174, 384)
	},
	RadiantBase = {
		[1] = Vector(-7136, -3040, 384), [2] = Vector(-5603, -3101, 384),
		[3] = Vector(-4697, -3576, 384), [4] = Vector(-3926, -4384, 384),
		[5] = Vector(-3616, -5664, 384), [6] = Vector(-3552, -7200, 384),
		[7] = Vector(-6942, -7200, 512), [8] = Vector(-7456, -6560, 512),
		[9] = Vector(-7712, -5664, 384)
	},
	TopLane = {
		[1] = Vector(-6170.25, -3973.95, 384), [2] = Vector(-6235.78, -3047.83, 371.91), 
		[3] = Vector(-6074.59, -2254.97, 256), [4] = Vector(-5666.02, -1577.11, 256), 
		[5] = Vector(-5684.65, 796.03, 256), [6] = Vector(-5828.39, 2530.5, 256), 
		[7] = Vector(-5915.92, 3767.5, 256), [8] = Vector(-5568.6, 5085.88, 256), 
		[9] = Vector(-4999.44, 5408.5, 256), [10] = Vector(-3696.29, 5743.64, 256), 
		[11] = Vector(-924.03, 5818.42, 256), [12] = Vector(-375.37, 5471.42, 256), 
		[13] = Vector(2889.75, 5402.44, 292.88), [14] = Vector(4071.61, 5231.63, 384), 
		[15] = Vector(4067.74, 6338.73, 384), [16] = Vector(3040.11, 6193.21, 368.06), 
		[17] = Vector(76.74, 6245.83, 256), [18] = Vector(-580.54, 6502.43, 256), 
		[19] = Vector(-5860.3, 6360.77, 256), [20] = Vector(-6466.85, 4929.23, 256), 
		[21] = Vector(-6626.74, 3228.57, 256), [22] = Vector(-6683.14, 2255.32, 256), 
		[23] = Vector(-6674.79, -599.12, 256), [24] = Vector(-6931.52, -1515.56, 256), 
		[25] = Vector(-6971.52, -3051.71, 373.85), [26] = Vector(-7020.02, -3922.02, 384)
	},
	MidLane = {
		[1] = Vector(-5444.42, -5378.45, 384), [2] = Vector(-4084.84, -4133.3, 384), 
		[3] = Vector(-2753.87, -2714.03, 256), [4] = Vector(-625.59, -950.98, 256), 
		[5] = Vector(46.34, -250.26, 256), [6] = Vector(900.3, 238.28, 256), 
		[7] = Vector(2764.55, 1570.73, 256), [8] = Vector(4219.38, 3201.65, 382.52), 
		[9] = Vector(5470.37, 4441.8, 384), [10] = Vector(4967.58, 4975.18, 384), 
		[11] = Vector(3690.11, 3730.35, 382.23), [12] = Vector(2449.23, 2384.78, 256), 
		[13] = Vector(1060.98, 985.29, 256), [14] = Vector(341.83, 781.48, 256), 
		[15] = Vector(-395.02, 150.97, 256), [16] = Vector(-1038.29, -521.24, 256), 
		[17] = Vector(-3472.47, -2378.73, 256), [18] = Vector(-4631.72, -3612.43, 384), 
		[19] = Vector(-5891.79, -4855.43, 384)
	},
	BotLane = {
		[1] = Vector(-4583.81, -6479.49, 384), [2] = Vector(-3551.98, -6492.36, 382.17), 
		[3] = Vector(-3039.49, -6703.26, 256), [4] = Vector(-179.97, -6596.05, 256), 
		[5] = Vector(3211.4, -6421.93, 256), [6] = Vector(5704.21, -6168.98, 256), 
		[7] = Vector(6182.37, -5486.07, 256), [8] = Vector(6655.59, -3606.1, 256), 
		[9] = Vector(6626.55, -1825.4, 256), [10] = Vector(6544.2, 306.1, 256), 
		[11] = Vector(7018.36, 1581.88, 256), [12] = Vector(6691.88, 2531.82, 369.91), 
		[13] = Vector(6821.52, 3664.59, 384), [14] = Vector(5782.1, 3631.57, 384), 
		[15] = Vector(5973.56, 2550.88, 379.44), [16] = Vector(5955.4, 911.46, 256), 
		[17] = Vector(5656.77, 7.26, 256), [18] = Vector(5875.73, -774.72, 256), 
		[19] = Vector(5863.5, -2279.51, 256), [20] = Vector(5966.48, -3615.28, 256), 
		[21] = Vector(5887.41, -4696.13, 256), [22] = Vector(5324.41, -5496.09, 256), 
		[23] = Vector(4509.17, -5845.46, 256), [24] = Vector(3203.07, -5754.54, 256), 
		[25] = Vector(2440.25, -5998.63, 256), [26] = Vector(1469.45, -5675.81, 256), 
		[27] = Vector(593.7, -5731.29, 256), [28] = Vector(-361.39, -6135.6, 256), 
		[29] = Vector(-2035.1, -6055.4, 256), [30] = Vector(-3560.23, -5672.86, 383.69), 
		[31] = Vector(-4513.15, -5617.68, 384)
	},
	RoshPit = {
		[1] = Vector(-1942.06, 1710.72, 149.49), [2] = Vector(-2324.04, 1457.84, 156.18), 
		[3] = Vector(-2565.82, 1598.84, 160), [4] = Vector(-2687.2, 1796.05, 160), 
		[5] = Vector(-2596.94, 2040.94, 160), [6] = Vector(-2225.79, 2040.94, 160)
	},
	Jungle = {
		Dire = {
			TopLarge1 = {
				[1] = Vector(1793.27, 3662.66, 384), [2] = Vector(1814.53, 3141.24, 256), 
				[3] = Vector(763.55, 3126.09, 384), [4] = Vector(763.19, 3719.68, 384)
			},
			TopLarge2 = {
				[1] = Vector(-756.72, 3765.7, 384), [2] = Vector(118.41, 3771.61, 384), 
				[3] = Vector(123.99, 3117.26, 384), [4] = Vector(-756.67, 3120.55, 384)
			},
			TopLarge3 = {
				[1] = Vector(-3917.55, 3250.96, 362.82), [2] = Vector(-3922.02, 3963.9, 256), 
				[3] = Vector(-4761.39, 3963.9, 256), [4] = Vector(-4749.75, 3256.57, 256.01)
			},
			TopMedium1 = {
				[1] = Vector(-281.18, 2766.72, 384), [2] = Vector(-278.19, 1970.92, 384), 
				[3] = Vector(-1030.94, 1969.88, 384), [4] = Vector(-1035.57, 2760.28, 384)
			},
			TopMedium2 = {
				[1] = Vector(-1391.32, 4677.13, 384), [2] = Vector(-1389.29, 4038.98, 384), 
				[3] = Vector(-2110.99, 4031.9, 384), [4] = Vector(-2116.49, 4662.77, 384)
			},
			TopSmall1 = {
				[1] = Vector(-2142.74, 5198.48, 256), [2] = Vector(-2146.3, 4380.01, 361.28), 
				[3] = Vector(-3134.57, 4380.86, 256), [4] = Vector(-3136.54, 5206.4, 256)
			},
			BotLarge1 = {
				[1] = Vector(4744.4, 1095, 384), [2] = Vector(4748.28, 515.99, 384), 
				[3] = Vector(4011.76, 517.5, 384), [4] = Vector(4013.85, 1089.5, 384)
			},
			BotMedium1 = {
				[1] = Vector(3042.47, 440.57, 384), [2] = Vector(3043.49, -151.27, 384), 
				[3] = Vector(2313.81, -157.6, 384), [4] = Vector(2251.2, 544.31, 256)
			},
			BotAncient1 = {
				[1] = Vector(4512.63, -31.06, 384), [2] = Vector(4513.17, -750.21, 384), 
				[3] = Vector(3461.68, -751.24, 384), [4] = Vector(3462.89, -30.64, 384)
			}
		},
		Radiant = {
			BotLarge1 = {
				[1] = Vector(5317.87, -3791.76, 256), [2] = Vector(5315.17, -4826.34, 256), 
				[3] = Vector(4229.01, -4831.47, 256), [4] = Vector(4220.87, -3792.45, 256)
			},
			BotLarge2 = {
				[1] = Vector(269.11, -3030.19, 384), [2] = Vector(273.63, -3758.48, 384), 
				[3] = Vector(-611.09, -3764.98, 384), [4] = Vector(-647.53, -2990.06, 256)
			},
			BotLarge3 = {
				[1] = Vector(-1468.62, -3794.39, 256), [2] = Vector(-1478.79, -4635.52, 384), 
				[3] = Vector(-2218.7, -4630.73, 256), [4] = Vector(-2221.01, -3803.29, 256)
			},
			BotMedium1 = {
				[1] = Vector(173.22, -4121.84, 384), [2] = Vector(176.14, -5091.35, 384), 
				[3] = Vector(1118.43, -5085.41, 384), [4] = Vector(1111.55, -4122.57, 384)
			},
			BotMedium2 = {
				[1] = Vector(616.63, -1538.53, 256), [2] = Vector(613.86, -2375.95, 256), 
				[3] = Vector(-272.14, -2377.26, 256), [4] = Vector(-270.04, -1550.1, 256)
			},
			BotSmall1 = {
				[1] = Vector(3697.35, -4025.21, 219.39), [2] = Vector(3700.43, -4907.89, 256), 
				[3] = Vector(2782.34, -4907.02, 256), [4] = Vector(2780.83, -4032.88, 384)
			},
			TopLarge1 = {
				[1] = Vector(-4285.12, 105.53, 384), [2] = Vector(-4289.72, -637.96, 384), 
				[3] = Vector(-5166.82, -644.98, 384), [4] = Vector(-5164.32, 93.96, 384)
			},
			TopMedium1 = {
				[1] = Vector(-3474.72, 1122.66, 256), [2] = Vector(-3472.83, 199.26, 384), 
				[3] = Vector(-4166.88, 195.69, 384), [4] = Vector(-4148.85, 1076, 256)
			},
			TopAncient1 = {
				[1] = Vector(-2467.44, -194.25, 352.51), [2] = Vector(-2463.88, -1014.35, 379.5), 
				[3] = Vector(-3371.88, -1014.54, 384), [4] = Vector(-3360.42, -198.69, 384)
			}
		}
	}
}

function BotSupportLib:DebugDrawAllPlaces()
	Extensions:DrawPolygon(places.DireBase, "DireBase", 30)
	Extensions:DrawPolygon(places.RadiantBase, "RadiantBase", 30)
	Extensions:DrawPolygon(places.TopLane, "TopLane", 30)
	Extensions:DrawPolygon(places.MidLane, "MidLane", 30)
	Extensions:DrawPolygon(places.BotLane, "BotLane", 30)
	Extensions:DrawPolygon(places.RoshPit, "RoshPit", 30)
	for key, spot in pairs(places.Jungle.Radiant) do
		Extensions:DrawPolygon(spot, key, 30)
	end
	for key, spot in pairs(places.Jungle.Dire) do
		Extensions:DrawPolygon(spot, key, 30)
	end
end

--Move polygons to a globally accessible dictionary
function BotSupportLib:WardPosIsNotInIgnored(unit, pos)
	local wardplaced_ignore_zones = {
		[DOTA_TEAM_BADGUYS] = {
			{condition = GameRules.VGMAR:GetMegaCreepsStatus(2) == false,
				zones = {
					places.DireBase
				}
			}
		},
		[DOTA_TEAM_GOODGUYS] = {
			{condition = GameRules.VGMAR:GetMegaCreepsStatus(3) == false,
				zones = {
					places.RadiantBase
				}
			}
		}
	}
	if unit then
		local zones = wardplaced_ignore_zones[unit:GetTeamNumber()]
		for _,group in ipairs(zones) do
			if group.condition then
				for _, poly in ipairs(group.zones) do
					if Extensions:isPointInsidePolygon(pos, poly) then
						return false
					end
				end
			end
		end
		return true
	end
	return nil
end

local WardSpots = {
	DireSide = {
		DireTopT2WardSpot = {
			[1] = Vector(1070.78, 4916.8, 640), [2] = Vector(961.54, 4911.24, 640),
			[3] = Vector(972.78, 4826.47, 640), [4] = Vector(1076.56, 4823.24, 640)
		},
		DireBotT2WardSpot1 = {
			[1] = Vector(5055.52, 823.96, 640), [2] = Vector(5056.97, 725.02, 640),
			[3] = Vector(5117.58, 689.3, 640), [4] = Vector(5198.71, 765.34, 640),
			[5] = Vector(5160.98, 840.12, 640)
		},
		DireBotT2WardSpot2 = {
			[1] = Vector(5067.02, -713.07, 640), [2] = Vector(5062.77, -814.58, 640),
			[3] = Vector(5117.54, -835.09, 640), [4] = Vector(5180.45, -809.61, 640),
			[5] = Vector(5176.15, -707.45, 640)
		},
		DireTopBountyRight = {
			[1] = Vector(-2508.21, 3373.78, 256), [2] = Vector(-2608.53, 3302.82, 256),
			[3] = Vector(-2438.62, 3278.05, 256.01)
		},
		DireTopPowerUpRune = {
			[1] = Vector(-993.42, 1466.75, 256), [2] = Vector(-1006.52, 1307, 256),
			[3] = Vector(-830.42, 1138.13, 256), [4] = Vector(-695.17, 1362.7, 256)
		},
		DireBotPowerUpRune1 = {
			[1] = Vector(1926.71, -1145.98, 256), [2] = Vector(2056.03, -973.56, 256),
			[3] = Vector(2616.68, -1271.7, 256), [4] = Vector(2084.38, -1230.87, 256)
		},
		DireBotPowerUpRune2 = {
			[1] = Vector(3141.84, -1364.72, 384), [2] = Vector(3289.15, -1358.54, 384),
			[3] = Vector(3370.87, -1572.03, 384), [4] = Vector(3287.44, -1573.98, 384),
			[5] = Vector(3234.2, -1438.15, 384), [6] = Vector(3211.6, -1390.25, 384)
		},
		DireBotBounty = {
			[1] = Vector(3690.7, -1810.68, 256), [2] = Vector(3599.38, -2006.89, 256),
			[3] = Vector(3911.71, -2317.39, 253.16), [4] = Vector(4075.28, -2158.11, 256)
		},
		DireJungleEntranceMid = {
			[1] = Vector(-446.03, 1783.01, 379.51), [2] = Vector(-454.91, 1936.67, 384),
			[3] = Vector(-248.54, 1948.01, 384), [4] = Vector(-230.63, 2265.75, 384),
			[5] = Vector(213.03, 2261.51, 384), [6] = Vector(24.1, 1824.82, 384)
		},
		DireTopBountyToShrine = {
			[1] = Vector(-1749.48, 4002.27, 384), [2] = Vector(-1743.57, 3451.44, 384),
			[3] = Vector(-1605.45, 3450.43, 384), [4] = Vector(-1586.74, 3952.23, 384)
		},
		DireTopJungleLaneSide = {
			[1] = Vector(-5134.26, 4739.6, 256), [2] = Vector(-5428.51, 4772.27, 256),
			[3] = Vector(-5421.05, 4516.67, 256), [4] = Vector(-5142.67, 4515.19, 256)
		},
		DireTopJungleTopAboveBounty = {
			[1] = Vector(-3207.15, 4304.15, 256), [2] = Vector(-3561.53, 4313.27, 256),
			[3] = Vector(-3547.91, 4019.39, 256), [4] = Vector(-3354.28, 4129.86, 256)
		},
		DireMidLaneWard = {
			[1] = Vector(-477.15, 570.89, 256), [2] = Vector(-404.66, 214.83, 256),
			[3] = Vector(-193.23, -47.95, 256), [4] = Vector(91.15, -267.57, 256),
			[5] = Vector(341.38, -271.32, 256), [6] = Vector(78.78, -156.54, 256),
			[7] = Vector(-130.08, 15.55, 256), [8] = Vector(-325.06, 300.41, 256)
		},
		DireBotShrine = {
			[1] = Vector(2975.57, -570.93, 384), [2] = Vector(3126.02, -572.18, 384),
			[3] = Vector(3135.43, -821.01, 384), [4] = Vector(3308.33, -814.37, 384),
			[5] = Vector(3280, -506.41, 384), [6] = Vector(2988.09, -479.66, 384)
		},
		DireBotBaseWard = {
			[1] = Vector(4855.45, 2792.75, 384), [2] = Vector(5113.05, 2817.16, 384),
			[3] = Vector(5397.93, 2629.48, 384), [4] = Vector(5098.3, 2770.36, 384)
		},
		DireTopBarracksWard = {
			[1] = Vector(2423.24, 5905.69, 256), [2] = Vector(3085.9, 6204.68, 384), 
			[3] = Vector(3240.64, 6194.08, 384), [4] = Vector(3231.68, 5286.18, 384), 
			[5] = Vector(3058.35, 5286.18, 384), [6] = Vector(2410.53, 5639.09, 256)
		},
		DireMidBarracksWard = {
			[1] = Vector(3198.26, 3010.2, 256), [2] = Vector(3498.97, 2721.86, 256), 
			[3] = Vector(4224.66, 3218.58, 384), [4] = Vector(4405.8, 3297.28, 384), 
			[5] = Vector(3754.09, 3950.18, 384), [6] = Vector(3689.29, 3732.77, 383.03)
		},
		DireBotBarracksWard = {
			[1] = Vector(6442.77, 1889.2, 256), [2] = Vector(6734.47, 2536.81, 379.64), 
			[3] = Vector(6741.78, 2690.98, 384), [4] = Vector(5903.44, 2665.05, 384), 
			[5] = Vector(5927.99, 2526.37, 379.19), [6] = Vector(6218.61, 1897.83, 256)
		},
		DireTopLaneWard = {
			[1] = Vector(-5574.1, 3305.39, 256), [2] = Vector(-5808.94, 3308.25, 256), 
			[3] = Vector(-5816.44, 3101.02, 256), [4] = Vector(-5581.92, 3098.68, 256)
		},
		TinkerWardBot = {
			[1] = Vector(7739, -207.82, 640), [2] = Vector(7728.74, -296.39, 640), 
			[3] = Vector(7648, -295.37, 640), [4] = Vector(7661.08, -205.54, 640)
		},
		TinkerWardTop = {
			[1] = Vector(-2634.74, 7484.66, 640), [2] = Vector(-2637.02, 7400.74, 640), 
			[3] = Vector(-2724.22, 7405.68, 640), [4] = Vector(-2721.45, 7484.66, 640)
		}
	},
	RadiantSide = {
		RadiantTopJungleEntranceMid = {
			[1] = Vector(-2828.69, 451.39, 384), [2] = Vector(-2967.85, 444.65, 384),
			[3] = Vector(-2970.45, 22.63, 384), [4] = Vector(-2831.99, 23.75, 384)
		},
		RadiantTopT1WardSpot = {
			[1] = Vector(-5057.23, 2103.24, 512), [2] = Vector(-5179.34, 2098.57, 512),
			[3] = Vector(-5183.07, 1994.54, 512), [4] = Vector(-5053.24, 1991.33, 512)
		},
		RadiantBotJungleLaneSide = {
			[1] = Vector(5406.05, -3470.33, 256), [2] = Vector(5379.28, -3719.92, 256), 
			[3] = Vector(5084.81, -3696.83, 256), [4] = Vector(5230.83, -3523.31, 256)
		},
		RadiantBotJungleLaneSide1 = {
			[1] = Vector(5446.23, -4817.52, 256), [2] = Vector(5334.41, -4808.56, 256), 
			[3] = Vector(5322.7, -4918.19, 256), [4] = Vector(5439.5, -4919.34, 256)
		},
		RadiantBotJungleAboveShrine = {
			[1] = Vector(2240.8, -3613.68, 384), [2] = Vector(2067.07, -3734.74, 384), 
			[3] = Vector(2421.19, -4036.5, 384), [4] = Vector(2556.84, -3902.43, 384)
		},
		RadiantMidLaneWard = {
			[1] = Vector(-1321.77, -277.8, 256), [2] = Vector(-1450.22, -382.91, 256), 
			[3] = Vector(-1128.92, -587.9, 256), [4] = Vector(-917.65, -726.05, 256), 
			[5] = Vector(-715.67, -1006.17, 256), [6] = Vector(-570.99, -1177.68, 256), 
			[7] = Vector(-563.8, -1079.89, 256), [8] = Vector(-717.02, -873.11, 256), 
			[9] = Vector(-900.09, -664.75, 256), [10] = Vector(-1095.08, -554.7, 256)
		},
		RadiantTopT2WardSpot = {
			[1] = Vector(-4394.43, -962.76, 640), [2] = Vector(-4404.43, -1050.64, 640), 
			[3] = Vector(-4291.46, -1051.41, 640), [4] = Vector(-4301.19, -973.94, 640)
		},
		RadiantBotJungleShrine = {
			[1] = Vector(1192.97, -4331.56, 384), [2] = Vector(1197.22, -4684.19, 384), 
			[3] = Vector(1642.66, -4615.4, 384), [4] = Vector(1656.63, -4245.06, 384)
		},
		RadiantBotT2WardSpot = {
			[1] = Vector(-977.36, -4545.48, 640), [2] = Vector(-1076.99, -4556.92, 640), 
			[3] = Vector(-1072.23, -4646.99, 640), [4] = Vector(-981.6, -4640.89, 640)
		},
		RadiantBotJungleAboveShrine1 = {
			[1] = Vector(553.04, -2850.42, 384), [2] = Vector(1053.33, -3142.7, 384), 
			[3] = Vector(1326.59, -2995.61, 384), [4] = Vector(1250.95, -2841.18, 384)
		},
		RadiantBotPowerUpRune = {
			[1] = Vector(1658.46, -2279, 256), [2] = Vector(1961.09, -2441.16, 256), 
			[3] = Vector(2316.83, -2628.93, 256), [4] = Vector(2007.16, -2342.81, 256)
		},
		RadiantBotPowerUpRune1 = {
			[1] = Vector(2973.23, -2757.1, 256), [2] = Vector(2838.49, -2759.56, 256), 
			[3] = Vector(2874.74, -2854.19, 256), [4] = Vector(3006.14, -2829.39, 256)
		},
		RadiantTopPowerUpRune = {
			[1] = Vector(-1559.85, 257.31, 256), [2] = Vector(-1779.05, 492.76, 256), 
			[3] = Vector(-2496.36, 487.27, 256), [4] = Vector(-2480.81, 399.22, 256), 
			[5] = Vector(-1917.6, 369.06, 256)
		},
		RadiantTopPowerUpRune1 = {
			[1] = Vector(-2793.09, 811.76, 384), [2] = Vector(-2937.33, 818.27, 384), 
			[3] = Vector(-2933.2, 773.65, 384), [4] = Vector(-2808, 764.38, 384)
		},
		RadiantMidT2Jungle = {
			[1] = Vector(-2615.41, -3759.22, 256), [2] = Vector(-2773.98, -3756.14, 256), 
			[3] = Vector(-2774.48, -3931.37, 256), [4] = Vector(-2631.82, -3932.68, 256)
		},
		RadiantMidT2TopJungle = {
			[1] = Vector(-3055.14, -1256.01, 384), [2] = Vector(-3141.29, -1166.76, 384), 
			[3] = Vector(-3202.89, -1245.26, 384), [4] = Vector(-3124.4, -1314.41, 384)
		},
		RadiantBotT2TowerPushHighGround = {
			[1] = Vector(379.78, -5147.48, 384), [2] = Vector(377.09, -5334.01, 384), 
			[3] = Vector(750.79, -5330.26, 384), [4] = Vector(769.76, -5134, 384)
		},
		RadiantBaseWard = {
			[1] = Vector(-5552.99, -3205.91, 384), [2] = Vector(-5553.15, -3320.27, 384), 
			[3] = Vector(-5395.16, -3346.61, 384), [4] = Vector(-5369.86, -3273.03, 384)
		},
		TinkerWardBot = {
			[1] = Vector(2608.32, -7112.06, 640), [2] = Vector(2610.28, -7201.78, 640), 
			[3] = Vector(2508.8, -7198.62, 640), [4] = Vector(2510.22, -7110.89, 640)
		},
		TinkerWardTop = {
			[1] = Vector(-7653.91, 574.42, 640), [2] = Vector(-7643.16, 475.82, 640), 
			[3] = Vector(-7738.74, 470.85, 640), [4] = Vector(-7738.14, 554.39, 640)
		}
	},
	LaneSentry = {
		BottomLane = {
			[1] = Vector(5974.69, -4297.53, 256), [2] = Vector(5922.58, -4768.7, 256), 
			[3] = Vector(5587.07, -5176.36, 256), [4] = Vector(6072.45, -5520.35, 256), 
			[5] = Vector(6479.46, -4895.31, 256), [6] = Vector(6572.67, -4310.3, 256)
		},
		MidLane = {
			[1] = Vector(-485.98, 450.23, 256), [2] = Vector(-380.52, 131.45, 256), 
			[3] = Vector(-1052.59, -529.92, 256), [4] = Vector(-1254.5, -390.68, 256), 
			[5] = Vector(-542.71, -1192.5, 256), [6] = Vector(-657.3, -914.97, 256), 
			[7] = Vector(31.69, -219.54, 256), [8] = Vector(216.14, -241.86, 256), 
			[9] = Vector(-145.65, 18.27, 256)
		},
		TopLane = {
			[1] = Vector(-5440.93, 5291.76, 256), [2] = Vector(-5767.91, 4950.96, 256), 
			[3] = Vector(-5965.39, 4504.67, 256), [4] = Vector(-6488.36, 4575.32, 256), 
			[5] = Vector(-6334.17, 5254.65, 256), [6] = Vector(-6047.47, 5694.58, 256)
		}
	}
}

function BotSupportLib:DebugDrawAllWardSpots()
	for key, spot in pairs(WardSpots.DireSide) do
		Extensions:DrawPolygon(spot, key, 30)
	end
	for key, spot in pairs(WardSpots.RadiantSide) do
		Extensions:DrawPolygon(spot, key, 30)
	end
	for key, spot in pairs(WardSpots.LaneSentry) do
		Extensions:DrawPolygon(spot, key, 30)
	end
end

function BotSupportLib:TimeIsLaterThan( minute, second )
	return GameRules.VGMAR:TimeIsLaterThan( minute, second )
end

function BotSupportLib:FindValidNearbyWardSpot(unit, wardtype)
	--Format:
	--Condition
	--Spots
	--WTypes: 1 - observer, 2 - sentry, 3 - both
	--[[Template:
			{condition = ,
				spot = {
					
				},
				id = ,
				range = ,
				wtypes = 
			},
	--]]
	--TODO:Add Temporary Sentry Ward Spots For Dewarding
	local condition_list = {
		[DOTA_TEAM_BADGUYS] = {
			{condition = not BotSupportLib:TimeIsLaterThan(20, 0) or not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 1, "mid"),
				spot = {
					WardSpots.DireSide.DireMidLaneWard
				},
				id = 1,
				range = 1500,
				wtypes = 1
			},
			{condition = (GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 1, "top") and not BotSupportLib:TimeIsLaterThan(15, 0)) or not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 1, "top"),
				spot = {
					WardSpots.DireSide.DireTopJungleLaneSide,
					WardSpots.DireSide.DireTopLaneWard
				},
				id = 3,
				range = 1500,
				wtypes = 1
			},
			{condition = not BotSupportLib:TimeIsLaterThan(20, 0) or not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 1, "bot"),
				spot = {
					WardSpots.RadiantSide.RadiantBotJungleLaneSide1
				},
				id = 4,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(9, 0) and (GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 1, "top") or not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 2, "top")),
				spot = {
					WardSpots.RadiantSide.RadiantTopT1WardSpot
				},
				id = 5,
				range = 1500,
				wtypes = 1
			},
			{condition = (BotSupportLib:TimeIsLaterThan(15, 0) and not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 1, "top")) or not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 2, "top"),
				spot = {
					WardSpots.RadiantSide.RadiantTopT2WardSpot
				},
				id = 6,
				range = 2000,
				wtypes = 1
			},
			{condition = not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 3, "top"),
				spot = {
					WardSpots.DireSide.DireTopBarracksWard
				},
				id = 7,
				range = 1000,
				wtypes = 3
			},
			{condition = not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 3, "mid"),
				spot = {
					WardSpots.DireSide.DireMidBarracksWard
				},
				id = 8,
				range = 1000,
				wtypes = 3
			},
			{condition = not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 3, "bot"),
				spot = {
					WardSpots.DireSide.DireBotBarracksWard
				},
				id = 9,
				range = 1000,
				wtypes = 3
			},
			{condition = (BotSupportLib:TimeIsLaterThan(15, 0) and GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 2, "mid")) or BotSupportLib:TimeIsLaterThan(25, 0),
				spot = {
					WardSpots.RadiantSide.RadiantMidT2Jungle
				},
				id = 10,
				range = 2000,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(25, 0),
				spot = {
					WardSpots.DireSide.DireTopPowerUpRune,
					WardSpots.RadiantSide.RadiantTopPowerUpRune1
				},
				id = 11,
				range = 1500,
				wtypes = 1
			},
			{condition = not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 3, "top"),
				spot = {
					WardSpots.DireSide.DireTopT2WardSpot
				},
				id = 12,
				range = 1500,
				wtypes = 1
			},
			{condition = not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 2, "bot"),
				spot = {
					WardSpots.DireSide.DireBotT2WardSpot2
				},
				id = 13,
				range = 1500,
				wtypes = 1
			},
			{condition = not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 2, "mid") or not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 2, "top"),
				spot = {
					WardSpots.RadiantSide.RadiantBaseWard
				},
				id = 14,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(40, 0) and not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 2, "bot"),
				spot = {
					WardSpots.RadiantSide.TinkerWardBot
				},
				id = 15,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(40, 0) and not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 2, "top"),
				spot = {
					WardSpots.RadiantSide.TinkerWardTop
				},
				id = 16,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(40, 0) and not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 2, "bot"),
				spot = {
					WardSpots.DireSide.TinkerWardBot
				},
				id = 17,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(40, 0) and not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 2, "top"),
				spot = {
					WardSpots.DireSide.TinkerWardTop
				},
				id = 18,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(10, 0) and GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 1, "mid"),
				spot = {
					WardSpots.RadiantSide.RadiantTopJungleEntranceMid
				},
				id = 19,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(20, 0) and not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 1, "top"),
				spot = {
					WardSpots.DireSide.DireTopJungleTopAboveBounty
				},
				id = 20,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(5, 0) and (GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 1, "bot") and GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 1, "mid")),
				spot = {
					WardSpots.DireSide.DireBotPowerUpRune1,
					WardSpots.DireSide.DireBotPowerUpRune2,
					WardSpots.DireSide.DireBotBounty
				},
				id = 21,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(15, 0) and not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 1, "mid"),
				spot = {
					WardSpots.RadiantSide.RadiantMidT2TopJungle
				},
				id = 22,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(15, 0) and not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 1, "bot"),
				spot = {
					WardSpots.RadiantSide.RadiantBotT2TowerPushHighGround
				},
				id = 23,
				range = 1500,
				wtypes = 1
			},
			{condition = BotSupportLib:TimeIsLaterThan(20, 0) and not (GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 1, "bot") and GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_BADGUYS, 1, "mid")),
				spot = {
					WardSpots.DireSide.DireBotShrine
				},
				id = 24,
				range = 1500,
				wtypes = 1
			},
			--LaneSentry
			{condition = not BotSupportLib:TimeIsLaterThan(15, 0) and #BotSupportLib.heroeswithinviscapabilities > 0,
				spot = {
					WardSpots.LaneSentry.BottomLane
				},
				id = 80,
				range = 1500,
				wtypes = 2
			},
			{condition = not BotSupportLib:TimeIsLaterThan(15, 0) and #BotSupportLib.heroeswithinviscapabilities > 0,
				spot = {
					WardSpots.LaneSentry.MidLane
				},
				id = 81,
				range = 1500,
				wtypes = 2
			},
			{condition = not BotSupportLib:TimeIsLaterThan(15, 0) and #BotSupportLib.heroeswithinviscapabilities > 0,
				spot = {
					WardSpots.LaneSentry.TopLane
				},
				id = 82,
				range = 1500,
				wtypes = 2
			}
		},
		[DOTA_TEAM_GOODGUYS] = {
			{condition = not BotSupportLib:TimeIsLaterThan(20, 0) or not GameRules.VGMAR:GetTierTowersStatus(DOTA_TEAM_GOODGUYS, 1, "mid"),
				spot = {
					WardSpots.RadiantSide.RadiantMidLaneWard
				},
				id = 99,
				range = 1500,
				wtypes = 1
			}
		}
	}
	local near_wards = {}
	if unit then
		--Check Dynamic Sentry Ward Spot List
		if wardtype == 2 then
			local dynsentryspots = {}
			for _, wardn in ipairs(BotSupportLib.wards[Extensions:GetOpposingTeamNumber(unit:GetTeamNumber())].observer) do
				if type(wardn) == 'number' then
					local warddata = BotSupportLib.wards[Extensions:GetOpposingTeamNumber(unit:GetTeamNumber())].observer[wardn]
					if not warddata.ward:IsNull() and warddata.ward:IsAlive() then
						if BotSupportLib:CheckNoWardNearbyCoord(unit:GetTeamNumber(), warddata.coord, KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_sentry'), 'true_sight_range'))[2] then
							if Extensions:GetCoordDistance(unit:GetAbsOrigin(), warddata.coord) < 2000 and not Extensions:IsVisibleToTeam(warddata.ward, unit:GetTeamNumber()) then
								table.insert(dynsentryspots, warddata.coord)
								if BotSupportLib:DebugDraw() then print('placing sentry ward against ward #'..tostring(wardn)..' from the ward database') end
							end
						end
					end
				end
			end
			if #dynsentryspots > 0 then
				local midpoint = dynsentryspots[1]
				for _, pos in ipairs(dynsentryspots) do
					if Extensions:GetCoordDistance(midpoint, pos) < KeyValuesManager:GetAbilitySpecialKV(KeyValuesManager:GetItemKV('item_ward_sentry'), 'true_sight_range') then
						if midpoint.x ~= 0 and midpoint.y ~= 0 and midpoint.z ~= 0 then
							midpoint = (midpoint + pos) / 2
						else
							midpoint = pos
						end
					end
				end
				return {midpoint, nil}
			end
		end
		--Build a list of Ward Spots Nearby
		local wlist = condition_list[unit:GetTeamNumber()]
		for _, group in ipairs(wlist) do
			if wardtype == group.wtypes or group.wtypes == 3 then
				local groupincreasedrange = false
				if group.condition and (not BotSupportLib.wardspottimestamp[group.id] or (BotSupportLib.wardspottimestamp[group.id] and BotSupportLib.wardspottimestamp[group.id] < GameRules:GetDOTATime(false, false))) then
					if wardtype == 3 then
						if BotSupportLib:CheckNoWardNearby(unit:GetTeamNumber(), group.spot)[1] and BotSupportLib:CheckNoWardNearby(unit:GetTeamNumber(), group.spot)[2] then
							for _, poly in ipairs(group.spot) do
								if Extensions:GetCoordDistance(unit:GetAbsOrigin(), Extensions:getPolygonMidPoint(poly)) < (group.range + math.bool(groupincreasedrange) * group.range or 1500) then
									groupincreasedrange = true
									table.insert(near_wards, {Extensions:getRandomPointInPolygon(poly), group.id})
								end
							end
						end
					elseif BotSupportLib:CheckNoWardNearby(unit:GetTeamNumber(), group.spot)[wardtype] then
						for _, poly in ipairs(group.spot) do
							if Extensions:GetCoordDistance(unit:GetAbsOrigin(), Extensions:getPolygonMidPoint(poly)) < (group.range + math.bool(groupincreasedrange) * group.range or 1500) then
								groupincreasedrange = true
								table.insert(near_wards, {Extensions:getRandomPointInPolygon(poly), group.id})
							end
						end
					end
				end
			end
		end
		return table.random(near_wards)
	end
end

function BotSupportLib:GetClosestVisibleEnemyWardInRange(hero, range)
	if hero then
		local wards = {}
		for _, ward in ipairs(Entities:FindAllByClassnameWithin("npc_dota_ward_base", hero:GetAbsOrigin(), range)) do
			if ward:GetTeamNumber() ~= hero:GetTeamNumber() and ward:IsAlive() then
				if Extensions:IsVisibleToTeam(ward, Extensions:GetOpposingTeamNumber(ward:GetTeamNumber())) then
					table.insert(wards, ward)
				end
			end
		end
		for _, ward in ipairs(Entities:FindAllByClassnameWithin("npc_dota_ward_base_truesight", hero:GetAbsOrigin(), range)) do
			if ward:GetTeamNumber() ~= hero:GetTeamNumber() and ward:IsAlive() then
				if Extensions:IsVisibleToTeam(ward, Extensions:GetOpposingTeamNumber(ward:GetTeamNumber())) then
					table.insert(wards, ward)
				end
			end
		end
		local ret = {nil, 99999999}
		for _, ward in ipairs(wards) do
			if Extensions:GetUnitDistance(hero, ward) < ret[2] and ward:IsAlive() then
				ret[1] = ward
				ret[2] = Extensions:GetUnitDistance(hero, ward)
			end
		end
		return ret[1]
	end
	return nil
end

--TODO:Add Bot wards addition and determine the conditions(add every bot ward or use same checks as human placed wards)
--TODO:Add a table of ignore zones(e.g next to ancient, outside of the map etc.)
function BotSupportLib:OnWardPlaced(unit, owner, wardtype)
	if unit and owner then
		if owner and self:IsHeroBotControlled(owner) == false then
			if (Extensions:IsVisibleToTeam(owner, Extensions:GetOpposingTeamNumber(owner:GetTeamNumber())) and math.random(1, 100) <= wardingsettings.placementdetectionchance.visible) or (Extensions:IsVisibleToTeam(owner, Extensions:GetOpposingTeamNumber(owner:GetTeamNumber())) == false and math.random(1, 100) <= wardingsettings.placementdetectionchance.notvisible) then
				local wtable = BotSupportLib.wards[owner:GetTeamNumber()][wardtype]
				table.insert(wtable, unit:entindex())
				wtable[unit:entindex()] = {ward = unit, timestamp = GameRules:GetDOTATime(false, false), coord = owner.wardpos, wardspot = nil}
			end
		elseif owner and self:IsHeroBotControlled(owner) == true then
			local wtable = BotSupportLib.wards[owner:GetTeamNumber()][wardtype]
			table.insert(wtable, unit:entindex())
			wtable[unit:entindex()] = {ward = unit, timestamp = GameRules:GetDOTATime(false, false), coord = owner.wardpos, wardspot = owner.wardspot}
		end
	end
end

function BotSupportLib:OnKilledUnit(attacker, unit, event)
	if attacker and unit and event then
		local index = attacker:entindex()
		local uindex = unit:entindex()
		if unit:GetClassname() == "npc_dota_ward_base" or unit:GetClassname() == "npc_dota_ward_base_truesight" then
			local wtype = "observer"
			if unit:GetClassname() == "npc_dota_ward_base_truesight" then
				wtype = "sentry"
			end
			local wtableentry = BotSupportLib.wards[unit:GetTeamNumber()][wtype][uindex]
			if wtableentry and wtableentry.wardspot then
				if BotSupportLib.wardspottimestamp[wtableentry.wardspot] == nil then
					table.insert(BotSupportLib.wardspottimestamp, wtableentry.wardspot)
					BotSupportLib.wardspottimestamp[wtableentry.wardspot] = GameRules:GetDOTATime(false, false) + 300
				elseif BotSupportLib.wardspottimestamp[wtableentry.wardspot] < GameRules:GetDOTATime(false, false) + 300 then
					BotSupportLib.wardspottimestamp[wtableentry.wardspot] = GameRules:GetDOTATime(false, false) + 300
				end
			end
		end
		if self:IsHeroBSLSupported(attacker) then
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				
			end
		end
	end
end

function BotSupportLib:OnPlayerAbilityCast(unit, ability, target, event)
	if unit and ability and event then
		if ability:GetName() == "furion_sprout" then
			BotSupportLib:OnNaturesProphetSproutCast(ability:GetCursorPosition(), unit, event)
		end
	end
end

function BotSupportLib:OnNaturesProphetSproutCast(vector, caster, event)
	local sprout_radius = 150
	local enemy_radius = 1000
	local iFactor = 0
	local nearby_enemies = FindUnitsInRadius(caster:GetTeamNumber(), vector, nil, enemy_radius, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, DOTA_UNIT_TARGET_FLAG_NONE, FIND_CLOSEST, false)
	if #nearby_enemies > 0 then
		local is_visible = false
		local visible_pos = nil
		for _, enemy in ipairs(nearby_enemies) do
			local visible_position = enemy:GetAbsOrigin() + (Extensions:GetPtoPDirectionVector(enemy:GetAbsOrigin(), vector) * ((enemy:GetAbsOrigin() - vector):Length2D() - (sprout_radius * 1.2)))
			if BotSupportLib:DebugDraw() then
				DebugDrawLine(enemy:GetAbsOrigin(), visible_position, 200, 200, 255, true, 5)
			end
			if Extensions:IsPositionFoWVisible(visible_position, enemy) then
				is_visible = true
				visible_pos = visible_position
				break
			end
		end
		if is_visible then
			if BotSupportLib:DebugDraw() then
				DebugDrawBox(visible_pos, Vector(-3, -3, 0), Vector(3, 3, 0), 255, 255, 255, 180, 5)
			end
			local captured_units = FindUnitsInRadius(caster:GetTeamNumber(), vector, nil, sprout_radius, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO, DOTA_UNIT_TARGET_FLAG_NONE, FIND_CLOSEST, false)
			--TODO: Rework to somehow query bots memory for enemy hero position data and see if anyone is inside instead of cheating
			if #captured_units > 0 then
				iFactor = 2
			else
				iFactor = math.random(0,1)
			end
			for _, enemy in ipairs(nearby_enemies) do
				if enemy:GetHealthPercent() > 0.5 then
					local best_spell = nil
					local dist = Extensions:GetPtoPDistance(enemy:GetAbsOrigin(), vector)
					if anti_np_abilities[enemy:GetName()] ~= nil then
						for spellname, usagedata in pairs(anti_np_abilities[enemy:GetName()]) do
							local spell = enemy:FindAbilityByName(spellname)
							if spell then
								local range = usagedata.range
								if range == -1 then
									range = KeyValuesManager:GetAbilityKV(spellname)["AbilityCastRange"]
								end
								if dist <= range and iFactor >= usagedata.importance then
									if BotSupportLib:GetAbilityCastConditions(enemy, spell) and BotSupportLib:GetAbilityCastManaConditions(enemy, spell, {}, 0.2) then
										if BotSupportLib:DebugDraw() then print(enemy:GetName().." selected "..spellname.." for use against "..caster:GetName()) end
										best_spell = {spell, usagedata.pt, range}
										break
									end
								end
							end
						end
					end
					if best_spell ~= nil then
						if best_spell[2] then
							if BotSupportLib:DebugDraw() then
								print(enemy:GetName().." casting "..best_spell[1]:GetName().." on vector ("..vector.x..","..vector.y..","..vector.z..")")
								DebugDrawLine(enemy:GetOrigin(), vector, 128, 255, 255, true, 2)
								DebugDrawCircle(vector, Vector(128, 255, 255), 100, sprout_radius, true, 2)
								DebugDrawCircle(enemy:GetOrigin(), Vector(128, 255, 128), 255, 15, true, 2)
							end
							BotSupportLib:CastAbility(enemy, DOTA_UNIT_ORDER_CAST_POSITION, nil, best_spell[1], vector, false, true, true)
						else
							if BotSupportLib:DebugDraw() then
								print(enemy:GetName().." casting "..best_spell[1]:GetName())
								DebugDrawCircle(enemy:GetOrigin(), Vector(128, 255, 128), 255, best_spell[3], true, 2)
								DebugDrawLine(enemy:GetOrigin(), vector, 128, 255, 255, true, 2)
							end
							BotSupportLib:CastAbility(enemy, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, best_spell[1], nil, false, true, true)
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:OnDamaged(unit, attacker, event)
	if unit and attacker and event then
		local aindex = attacker:entindex()
		local uindex = unit:entindex()
		--Tracking Damage
		if unit:IsRealHero() then
			Extensions:TrackDamage(uindex, event.damage, event.damage_type, (attacker:IsHero() or ((attacker:IsSummoned() or attacker:IsDominated()) and (attacker:GetPlayerOwner() ~= nil))))
		end
		if unit:IsRealHero() and self:IsHeroBotControlled(unit) then
			--/////////////////////////////////////////////
			--Escape and Defence Fast Response Logic
			--/////////////////////////////////////////////
			if unit:IsAlive() and unit:IsInvisible() == false then
				if InvManager:HeroHasReadyItemInInventory( unit, "item_black_king_bar", false, false, false ) then
					local bkb = InvManager:GetItemFromInventoryByName( unit, "item_black_king_bar", false, false, false )
					if bkb ~= nil and bkb:IsFullyCastable() and Extensions:QueryHeroDamage(unit:entindex(), 2, 2, true, false) >= unit:GetMaxHealth()*0.1 then
						BotSupportLib:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, bkb, nil, false, true, true)
					end
				--Blademail
				elseif InvManager:HeroHasReadyItemInInventory( unit, "item_blade_mail", false, false, false ) then
					local blademail = InvManager:GetItemFromInventoryByName( unit, "item_blade_mail", false, false, false )
					if blademail ~= nil and blademail:IsFullyCastable() and Extensions:QueryHeroDamage(unit:entindex(), 2, 1+4+(2*math.bool(unit:HasModifier("modifier_black_king_bar_immune") == false)), true, false) >= unit:GetMaxHealth()*0.1 then
						BotSupportLib:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, blademail, nil, false, true, true)
					end
				--Ghost Scepter
				elseif InvManager:HeroHasReadyItemInInventory( unit, "item_ghost", false, false, false ) then
					local ghost = InvManager:GetItemFromInventoryByName( unit, "item_ghost", false, false, false )
					if ghost ~= nil and ghost:IsFullyCastable() and Extensions:QueryHeroDamage(unit:entindex(), 2, 1, true, false) >= unit:GetMaxHealth()*0.1 then
						BotSupportLib:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, ghost, nil, false, true, true)
					end
				--ShadowBlade/SilverEdge
				elseif (InvManager:HeroHasReadyItemInInventory( unit, "item_invis_sword", false, false, false ) or InvManager:HeroHasReadyItemInInventory( unit, "item_silver_edge", false, false, false )) then
					local invisitem = InvManager:GetItemFromInventoryByName( unit, "item_invis_sword", false, false, false )
					if invisitem == nil then
						invisitem = InvManager:GetItemFromInventoryByName( unit, "item_silver_edge", false, false, false )
					end
					if invisitem ~= nil and invisitem:IsFullyCastable() then
						if attacker:IsHero() and (unit:GetHealth()/unit:GetMaxHealth() < 0.35) and Extensions:QueryHeroDamage(unit:entindex(), 2, 1+2+4, true, false) >= unit:GetMaxHealth()*0.1 then
							BotSupportLib:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, invisitem, nil, false, true, true)
						end
					end
				end
			end
		end
		if self:IsHeroBSLSupported(attacker) then
			if self.botdata[aindex] ~= nil then
				local name = self.botdata[aindex].name
				
			end
		end
		if self:IsHeroBSLSupported(unit) then
			if self.botdata[uindex] ~= nil then
				local name = self.botdata[uindex].name
				if name == "npc_dota_hero_phantom_assassin" then
					local blur = self:GetAbilityFromDB(unit, "phantom_assassin_blur")
					if attacker:IsHero() and (unit:GetHealth()/unit:GetMaxHealth() < 0.7) then
						if BotSupportLib:GetClosestEnemyHero(attacker, -1)[2] > (blur:GetSpecialValueFor("radius")*1.15) then
							self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, blur, nil, false, true, true)
						end
					end
				elseif name == "npc_dota_hero_lich" then
					local shield = self:GetAbilityFromDB(unit, "lich_frost_shield")
					local ultimate = self:GetAbilityFromDB(unit, "lich_chain_frost")
					if self:GetAbilityCastConditions(unit, shield) and self:GetAbilityCastManaConditions(unit, shield, {ultimate}, 0.6) then
						if (unit:GetHealth()/unit:GetMaxHealth() < 0.7) and Extensions:QueryHeroDamage(unit:entindex(), 2, 1+2+4, true, false) >= unit:GetMaxHealth()*0.1 then
							self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_TARGET, unit, shield, nil, false, true, true, 0.2, 2)
						end
					end
				elseif name == "npc_dota_hero_necrolyte" then
					local shroud = self:GetAbilityFromDB(unit, "necrolyte_sadist")
					local ultimate = self:GetAbilityFromDB(unit, "necrolyte_reapers_scythe")
					if self:GetAbilityCastConditions(unit, shroud) and self:GetAbilityCastManaConditions(unit, shroud, {ultimate}, 0.2) then
						if Extensions:QueryHeroDamage(unit:entindex(), 2, 1, true, false) >= unit:GetMaxHealth()*0.1 and Extensions:GetUnitDistance(attacker, unit) <= attacker:Script_GetAttackRange()*1.2 then
							self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, shroud, nil, false, true, true)
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:OnDeath(unit, attacker, event)
	if attacker and unit and event then
		local index = unit:entindex()
		if self:IsHeroBSLSupported(unit) then
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				
			end
		end
	end
end

--AbilityFullyCast Tracking
function BotSupportLib:OnAbilityCast(unit, ability, target, event)
	if event and unit and ability then
		local index = unit:entindex()
		--Check if hero has modifications
		if self:IsHeroBSLSupported(unit) then
			--BotLogic
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				--Zeus
				if name == "npc_dota_hero_zuus" then
					local ultimate = self:GetAbilityFromDB( unit, "zuus_thundergods_wrath" )
					local nimbus = self:GetAbilityFromDB( unit ,"zuus_cloud" )
					local bolt = self:GetAbilityFromDB( unit, "zuus_lightning_bolt" )
					if ability == bolt then
						if self:GetAbilityCastConditions(unit, nimbus) and self:GetAbilityCastManaConditions(unit, nimbus, {}, 0.2) then
							if target and target:IsRealHero() then
								self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_POSITION, nil, nimbus, target:GetAbsOrigin(), false, true, true)
							end
						end
					elseif ability == ultimate then
						if self:GetAbilityCastConditions(unit, nimbus) and self:GetAbilityCastManaConditions(unit, nimbus, {}, 0.1) then
							Extensions:CallWithDelay(0.5, true, function()
								local enemy = self:GetLowestHealthEnemy(unit, -1)
								if enemy then
									self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_POSITION, nil, nimbus, enemy:GetAbsOrigin(), false, true, true)
								end
							end)
						end
					end
				--WraithKing
				elseif name == "npc_dota_hero_skeleton_king" then
					local stun = self:GetAbilityFromDB( unit, "skeleton_king_hellfire_blast")
					local aura = self:GetAbilityFromDB( unit, "skeleton_king_vampiric_aura")
					local crit = self:GetAbilityFromDB( unit, "skeleton_king_mortal_strike")
					local reincarnation = self:GetAbilityFromDB( unit, "skeleton_king_reincarnation")
					local skeletonsmodifier = self:GetModifierFromDB( unit, "modifier_skeleton_king_mortal_strike")
					if ability == stun then
						if target and target:IsHero() then
							if self:GetAbilityCastConditions(unit, crit) and self:GetAbilityCastManaConditions(unit, crit, {reincarnation}, 0.1) then
								if skeletonsmodifier and skeletonsmodifier:GetStackCount() >= crit:GetSpecialValueFor("max_skeleton_charges")/2 then
									self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, crit, nil, false, true, true)
								end
							end
						end
					end
				--Tiny
				elseif name == "npc_dota_hero_tiny" then
					local grab_tree = self:GetAbilityFromDB( unit, "tiny_craggy_exterior" )
					if ability == grab_tree then
						Extensions:CallWithDelay(0.5, true, function()
							self:AddModifierToDB(unit, "modifier_tiny_craggy_exterior", 15, true)
						end)
					end
				--Viper
				elseif name == "npc_dota_hero_viper" then
					local nethertoxin = self:GetAbilityFromDB( unit, "viper_nethertoxin" )
					local ultimate = self:GetAbilityFromDB( unit, "viper_viper_strike" )
					if ability == ultimate or ability:GetName() == "item_sheepstick" or ability:GetName() == "item_rod_of_atos" then
						if target and target:IsHero() then
							if self:GetAbilityCastConditions(unit, nethertoxin) and self:GetAbilityCastManaConditions(unit, nethertoxin, {}, 0.1) then
								self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_POSITION, nil, nethertoxin, target:GetAbsOrigin(), false, true, true)
							end
						end
					end
				--Lich
				elseif name == "npc_dota_hero_lich" then
					local blast = self:GetAbilityFromDB(unit, "lich_frost_nova")
					local gaze = self:GetAbilityFromDB(unit, "lich_sinister_gaze")
					local ultimate = self:GetAbilityFromDB(unit, "lich_chain_frost")
					if ability == blast or ability == ultimate then
						if target and target:IsHero() then
							if self:GetAbilityCastConditions(unit, gaze) and self:GetAbilityCastManaConditions(unit, gaze, {ultimate}, 0.1) then
								self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_TARGET, target, gaze, nil, false, true, true, 0.5, 1)
							end
						end
					end
				elseif name == "npc_dota_hero_phantom_assassin" then
					local blink = self:GetAbilityFromDB(unit, "phantom_assassin_phantom_strike")
					local blur = self:GetAbilityFromDB(unit, "phantom_assassin_blur")
					if ability == blink then
						if target and target:GetTeamNumber() == unit:GetTeamNumber() then
							if self:GetAbilityCastConditions(unit, blur) then
								Extensions:CallWithDelay(0.5, true, function()
									if BotSupportLib:GetClosestEnemyHero(unit, -1)[2] > (blur:GetSpecialValueFor("radius")*1.15) then
										self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, blur, nil, false, true, true, 0.3, 1)
									end
								end)
							end
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:AttachThinker(unit, thinkerid, fID, endfID, autostart, interval, timeout)
	if unit then
		local index = unit:entindex()
		if not self.botdata[unit:entindex()].thinkers[thinkerid] then
			local thinker = nil
			if fID > 0 or endfID > 0 then
				thinker = unit:AddNewModifier(unit, nil, "modifier_bsl_thinker", {
						functionid = fID,
						endfID = endfID,
						interval = interval or 0.5,
						timeout = timeout,
						autostart = (autostart == true)
					})
				table.insert(self.botdata[index].thinkers, thinkerid)
				self.botdata[index].thinkers[thinkerid] = thinker
				if autostart ~= nil and autostart ~= true then
					if not self.botdata[index].abilitythinkers[autostart] then
						table.insert(self.botdata[index].abilitythinkers, autostart)
						self.botdata[index].abilitythinkers[autostart] = {}
					end
					table.insert(self.botdata[index].abilitythinkers[autostart], thinker)
				end
			end
		end
	end
end

--TODO:Add conditional attachment(similar to intrinsic modifier) function
function BotSupportLib:IntervalFunctionCall(unit, fID)
	if unit then
		local name = unit:GetName()
		--WK Idle Skeleton Spawning
		if fID == 1 then
			if name == "npc_dota_hero_skeleton_king" then
				if self:GetClosestEnemyHero(unit, 1500) == nil then
					local crit = self:GetAbilityFromDB( unit, "skeleton_king_mortal_strike")
					local reincarnation = self:GetAbilityFromDB( unit, "skeleton_king_reincarnation")
					local skeletonsmodifier = self:GetModifierFromDB( unit, "modifier_skeleton_king_mortal_strike")
					if self:GetAbilityCastConditions(unit, crit) and self:GetAbilityCastManaConditions(unit, crit, {reincarnation}, 0.5) then
						if skeletonsmodifier and skeletonsmodifier:GetStackCount() >= crit:GetSpecialValueFor("max_skeleton_charges") then
							self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, crit, nil, false, true, true)
						end
					end
				end
			else
				return 2
			end
		--WK Aura Toggling on lane
		elseif fID == 2 then
			if name == "npc_dota_hero_skeleton_king" then
				local aura = self:GetAbilityFromDB(unit, "skeleton_king_vampiric_aura")
				if aura then
					local closesttower = FindUnitsInRadius(unit:GetTeamNumber(), unit:GetAbsOrigin(), nil, 2000, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_BUILDING, 0, FIND_CLOSEST, false)
					local idealstate = false
					if closesttower == nil then
						idealstate = true
					else
						idealstate = false
					end
					if aura:GetToggleState() ~= idealstate then
						aura:ToggleAbility()
					end
				end
			else
				return 2
			end
		--WK Aura Reenabling
		--OnRemoved Function
		elseif fID == 3 then
			if name == "npc_dota_hero_skeleton_king" then
				local aura = self:GetAbilityFromDB(unit, "skeleton_king_vampiric_aura")
				if aura then
					Timers:CreateTimer(2, function()
						if unit:IsAlive() then
							if aura:GetToggleState() ~= false then
								aura:ToggleAbility()
							end
						else
							return 2.0
						end
					end)
				end
			else
				return 2
			end
		--Tiny Grab Tree
		elseif fID == 4 then
			if name == "npc_dota_hero_tiny" then
				local tree_grab = self:GetAbilityFromDB(unit, "tiny_craggy_exterior")
				if unit:GetHealth()/unit:GetMaxHealth() > 0.6 and self:GetAbilityCastConditions(unit, tree_grab) and self:GetAbilityCastManaConditions(unit, tree_grab, {}, 0.2) then
					local tree = {nil,99999}
					for i,v in ipairs(GridNav:GetAllTreesAroundPoint(unit:GetAbsOrigin(), 600, true)) do
						if v and v:IsNull() == false then
							if v:IsStanding() and GridNav:CanFindPath(v:GetAbsOrigin() + (v:GetAbsOrigin()-unit:GetAbsOrigin()):Normalized()*100, unit:GetAbsOrigin()) then
								local distance = (v:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D()
								if tree[2] > (v:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D() then
									tree = {v, distance}
								end
							end
						end
					end
					if tree[1] then
						tree = tree[1]:entindex()
						--[[unit:AddNewModifier(unit, nil, "modifier_bsl_execute_order_processor", {
							ordertype = DOTA_UNIT_ORDER_CAST_TARGET_TREE,
							tindex = GetTreeIdForEntityIndex(tree),
							aindex = tree_grab:entindex(),
							pos = nil,
							queue = false,
							force = true,
							interval = 0.1,
							timeout = 4
						})--]]
						self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_TARGET_TREE, GetTreeIdForEntityIndex(tree), tree_grab, nil, false, true, true, 0.1, 4)
					end
				end
			else
				return 2
			end
		elseif fID == 5 then
			if name == "npc_dota_hero_lich" then
				local shield = self:GetAbilityFromDB(unit, "lich_frost_shield")
				local alliesnearby = FindUnitsInRadius(unit:GetTeamNumber(), unit:GetAbsOrigin(), nil, shield:GetCastRange()+200, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_HERO, 0, FIND_CLOSEST, false)
				local damagedally = {nil, 0}
				for _, ally in ipairs(alliesnearby) do
					if ally ~= unit then
						local dmg = Extensions:QueryHeroDamage(ally:entindex(), 2, 1+2+4, true, false)
						if dmg > damagedally[2] and ally:GetHealthPercent() > 5 and ally:IsInvulnerable() == false then
							damagedally = {ally, dmg}
						end
					end
				end
				if damagedally[1] ~= nil then
					if damagedally[2] >= damagedally[1]:GetMaxHealth()*0.1 then
						self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_TARGET, damagedally[1], shield, nil, false, true, true, 0.2, 2)
					end
				end
			else
				return 2
			end
		elseif fID == 6 then
			if name == "npc_dota_hero_omniknight" then
				local guardianangel = self:GetAbilityFromDB(unit, "omniknight_guardian_angel")
				local teamancient = nil
				if unit:GetTeamNumber() == DOTA_TEAM_BADGUYS then
					teamancient = GameRules.VGMAR.direanc
				else
					teamancient = GameRules.VGMAR.radiantanc
				end
				if teamancient and unit:HasScepter() then
					local anchealth = teamancient:GetHealthPercent()
					if anchealth < 20 and BotSupportLib:GetClosestEnemyHero(teamancient, 1000) ~= nil then
						if self:GetAbilityCastConditions(unit, guardianangel) and self:GetAbilityCastManaConditions(unit, guardianangel, {}, 0.1) then
							self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, guardianangel, nil, false, true, true)
						end
					end
				end
			end
		--Return Error Code if fID is not found
		else
			return 1
		end
	else
		return 3
	end
end

--OrderFilter Tracking
--Allows blocking actions
function BotSupportLib:OrderFilter(filterTable)
	local order_type = filterTable.order_type
	local units = filterTable["units"]
	local issuer = filterTable["issuer_player_id_const"]
	local unit = nil
	if units["0"] ~= nil then
		unit = EntIndexToHScript(units["0"])
	end
	local ability = EntIndexToHScript(filterTable.entindex_ability)
    local target = EntIndexToHScript(filterTable.entindex_target)
	
	if unit then
		local index = unit:entindex()
		--Check if hero has modifications
		if self:IsHeroBSLSupported(unit) then
			--BotLogic
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				--Sven Stuns units next to the target if target has linken(or substitutes) and nearby units dont
				if name == "npc_dota_hero_sven" then
					local stun = self:GetAbilityFromDB( unit, "sven_storm_bolt")
					if ability and ability == stun and target and target:IsHero() then
						if InvManager:HeroHasUsableItemInInventory( target, "item_sphere", false, false, false ) or BotSupportLib:CheckReflectModifiers(target) then
							local stunrange = stun:GetSpecialValueFor("bolt_aoe")
							local stuntargets = FindUnitsInRadius(unit:GetTeamNumber(), target:GetOrigin(), nil, stunrange*0.8, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_CREEP, 0, FIND_CLOSEST, false)
							local filteredstuntargets = {}
							if #stuntargets > 1 then
								for i=1,#stuntargets do
									if stuntargets[i] ~= target then
										if (stuntargets[i]:IsHero() and ((InvManager:HeroHasUsableItemInInventory( stuntargets[i], "item_sphere", false, false, false ) and BotSupportLib:CheckReflectModifiers(stuntargets[i])) == false)) then
											table.insert(filteredstuntargets, stuntargets[i])
										elseif stuntargets[i]:IsHero() == false then
											table.insert(filteredstuntargets, stuntargets[i])
										end
									end
								end
							end
							if #filteredstuntargets > 0 then
								local newtar = filteredstuntargets[math.random(1,#filteredstuntargets)]
								unit:CastAbilityOnTarget(newtar, stun, issuer)
								return false
							end
						end
					end
				end
			end
		end
	end
end

--/////////////////////////////////
--Assignment
GameRules.BotSupportLib = BotSupportLib