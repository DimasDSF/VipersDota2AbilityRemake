--[[["npc_dota_hero_queenofpain"]		=	"Queen of Pain",
	["npc_dota_hero_antimage"]			=	"Anti-Mage",
	["npc_dota_hero_kunkka"]			=	"Kunkka",
	["npc_dota_hero_lina"]				=	"Lina",
	["npc_dota_hero_mirana"]			=	"Mirana",
	["npc_dota_hero_slardar"]			=	"Slardar",
	["npc_dota_hero_lion"]				=	"Lion",
	["npc_dota_hero_phantom_assassin"]	=	"Phantom Assassin",
	["npc_dota_hero_tidehunter"]		=	"Tidehunter",
	["npc_dota_hero_witch_doctor"]		=	"Witch Doctor",
	["npc_dota_hero_vengefulspirit"]	=	"Vengeful Spirit",
	["npc_dota_hero_juggernaut"]		=	"Juggernaut",
	["npc_dota_hero_earthshaker"]		=	"Earthshaker",
	["npc_dota_hero_pudge"]				=	"Pudge",
	["npc_dota_hero_bane"]				=	"Bane",
	["npc_dota_hero_crystal_maiden"]	=	"Crystal Maiden",
	["npc_dota_hero_sven"]				=	"Sven",
	["npc_dota_hero_skeleton_king"]		=	"Wraith King",
	["npc_dota_hero_storm_spirit"]		=	"Storm Spirit",
	["npc_dota_hero_sand_king"]			=	"Sand King",
	["npc_dota_hero_nevermore"]			=	"Shadow Fiend",
	["npc_dota_hero_drow_ranger"]		=	"Drow Ranger",
	["npc_dota_hero_axe"]				=	"Axe",
	["npc_dota_hero_bloodseeker"]		=	"Bloodseeker",
	["npc_dota_hero_phantom_lancer"]	=	"Phantom Lancer",
	["npc_dota_hero_razor"]				=	"Razor",
	["npc_dota_hero_morphling"]			=	"Morphling",
	["npc_dota_hero_zuus"]				=	"Zeus",
	["npc_dota_hero_tiny"]				=	"Tiny",
	["npc_dota_hero_puck"]				=	"Puck",
	["npc_dota_hero_windrunner"]		=	"Windranger",
	["npc_dota_hero_lich"]				=	"Lich",
	["npc_dota_hero_shadow_shaman"]		=	"Shadow Shaman",
	["npc_dota_hero_riki"]				=	"Riki",
	["npc_dota_hero_enigma"]			=	"Enigma",
	["npc_dota_hero_tinker"]			=	"Tinker",
	["npc_dota_hero_sniper"]			=	"Sniper",
	["npc_dota_hero_necrolyte"]			=	"Necrophos",
	["npc_dota_hero_warlock"]			=	"Warlock",
	["npc_dota_hero_beastmaster"]		=	"Beastmaster",
	["npc_dota_hero_venomancer"]		=	"Venomancer",
	["npc_dota_hero_faceless_void"]		=	"Faceless Void",
	["npc_dota_hero_death_prophet"]		=	"Death Prophet",
	["npc_dota_hero_pugna"]				=	"Pugna",
	["npc_dota_hero_templar_assassin"]	=	"Templar Assassin",
	["npc_dota_hero_viper"]				=	"Viper",
	["npc_dota_hero_luna"]				=	"Luna",
	["npc_dota_hero_dragon_knight"]		=	"Dragon Knight",
	["npc_dota_hero_dazzle"]			=	"Dazzle",
	["npc_dota_hero_rattletrap"]		=	"Clockwerk",
	["npc_dota_hero_leshrac"]			=	"Leshrac",
	["npc_dota_hero_furion"]			=	"Nature's Prophet",
	["npc_dota_hero_life_stealer"]		=	"Lifestealer",
	["npc_dota_hero_dark_seer"]			=	"Dark Seer",
	["npc_dota_hero_clinkz"]			=	"Clinkz",
	["npc_dota_hero_omniknight"]		=	"Omniknight",
	["npc_dota_hero_enchantress"]		=	"Enchantress",
	["npc_dota_hero_huskar"]			=	"Huskar",
	["npc_dota_hero_night_stalker"]		=	"Night Stalker",
	["npc_dota_hero_broodmother"]		=	"Broodmother",
	["npc_dota_hero_bounty_hunter"]		=	"Bounty Hunter",
	["npc_dota_hero_weaver"]			=	"Weaver",
	["npc_dota_hero_jakiro"]			=	"Jakiro",
	["npc_dota_hero_batrider"]			=	"Batrider",
	["npc_dota_hero_chen"]				=	"Chen",
	["npc_dota_hero_spectre"]			=	"Spectre",
	["npc_dota_hero_doom_bringer"]		=	"Doom",
	["npc_dota_hero_ancient_apparition"]=	"Ancient Apparition",
	["npc_dota_hero_ursa"]				=	"Ursa",
	["npc_dota_hero_spirit_breaker"]	=	"Spirit Breaker",
	["npc_dota_hero_gyrocopter"]		=	"Gyrocopter",
	["npc_dota_hero_alchemist"]			=	"Alchemist",
	["npc_dota_hero_invoker"]			=	"Invoker",
	["npc_dota_hero_silencer"]			=	"Silencer",
	["npc_dota_hero_obsidian_destroyer"]=	"Outworld Devourer",
	["npc_dota_hero_lycan"]				=	"Lycan",
	["npc_dota_hero_brewmaster"]		=	"Brewmaster",
	["npc_dota_hero_shadow_demon"]		=	"Shadow Demon",
	["npc_dota_hero_lone_druid"]		=	"Lone Druid",
	["npc_dota_hero_chaos_knight"]		=	"Chaos Knight",
	["npc_dota_hero_treant"]			=	"Treant Protector",
	["npc_dota_hero_meepo"]				=	"Meepo",
	["npc_dota_hero_ogre_magi"]			=	"Ogre Magi",
	["npc_dota_hero_undying"]			=	"Undying",
	["npc_dota_hero_rubick"]			=	"Rubick",
	["npc_dota_hero_disruptor"]			=	"Disruptor",
	["npc_dota_hero_nyx_assassin"]		=	"Nyx Assassin",
	["npc_dota_hero_naga_siren"]		=	"Naga Siren",
	["npc_dota_hero_keeper_of_the_light"]=	"Keeper of the Light",
	["npc_dota_hero_visage"]			=	"Visage",
	["npc_dota_hero_wisp"]				=	"Io",
	["npc_dota_hero_slark"]				=	"Slark",
	["npc_dota_hero_medusa"]			=	"Medusa",
	["npc_dota_hero_troll_warlord"]		=	"Troll Warlord",
	["npc_dota_hero_centaur"]			=	"Centaur Warrunner",
	["npc_dota_hero_magnataur"]			=	"Magnus",
	["npc_dota_hero_shredder"]			=	"Timbersaw",
	["npc_dota_hero_bristleback"]		=	"Bristleback",
	["npc_dota_hero_tusk"]				=	"Tusk",
	["npc_dota_hero_skywrath_mage"]		=	"Skywrath Mage",
	["npc_dota_hero_abaddon"]			=	"Abaddon",
	["npc_dota_hero_elder_titan"]		=	"Elder Titan",
	["npc_dota_hero_legion_commander"]	=	"Legion Commander",
	["npc_dota_hero_ember_spirit"]		=	"Ember Spirit",
	["npc_dota_hero_earth_spirit"]		=	"Earth Spirit",
	["npc_dota_hero_abyssal_underlord"]	=	"Underlord",
	["npc_dota_hero_phoenix"]			=	"Phoenix",
	["npc_dota_hero_terrorblade"]		=	"Terrorblade",
	["npc_dota_hero_oracle"]			=	"Oracle",
	["npc_dota_hero_techies"]			=	"Techies",
	["npc_dota_hero_winter_wyvern"]		=	"Winter Wyvern",
	["npc_dota_hero_arc_warden"]		=	"Arc Warden",
	["npc_dota_hero_monkey_king"]		=	"Monkey King",
	["npc_dota_hero_pangolier"]			=	"Pangolier",
	["npc_dota_hero_dark_willow"]		=	"Dark Willow",
	["npc_dota_hero_grimstroke"]		=	"Grimstroke"]]--

if not BotSupportLib then
	BotSupportLib = class({})
end

function BotSupportLib:Init()
	print("[BotSupportLib] : Loading")
	LinkLuaModifier("modifier_bsl_execute_order_processor", "abilities/util/modifiers/modifier_bsl_execute_order_processor", LUA_MODIFIER_MOTION_NONE)
	LinkLuaModifier("modifier_bsl_eventhandler", "abilities/util/modifiers/modifier_bsl_eventhandler", LUA_MODIFIER_MOTION_NONE)
	LinkLuaModifier("modifier_bsl_thinker", "abilities/util/modifiers/modifier_bsl_thinker", LUA_MODIFIER_MOTION_NONE)
	ListenToGameEvent( "dota_player_learned_ability", Dynamic_Wrap( BotSupportLib, "OnAbilityLearned" ), self)
	
	Convars:RegisterCommand('bsl_force_reset_eop', Dynamic_Wrap( BotSupportLib, "ForceResetAllEOPs" ), "Resets all EOPs", 0)

	self.botheroes = {}
	self.botdata = {}
end

function BotSupportLib:ForceResetAllEOPs()
	local EOPs = {}
	for i,v in ipairs(HeroList:GetAllHeroes()) do
		for _,j in ipairs(v:FindAllModifiersByName("modifier_bsl_execute_order_processor")) do
			table.insert(EOPs, j)
		end
	end
	print("[BSL]::DEBUG:Resetting "..#EOPs.." Execute Order Processors")
	for _,j in ipairs(EOPs) do
		j:SetDuration(1,true)
	end
end

--TODO:Add events to track for the event response system
--TODO:Add Think Functions
local affectedheroeslist = {
	["npc_dota_hero_skeleton_king"] = {
		abilities = {
			"skeleton_king_hellfire_blast",
			"skeleton_king_vampiric_aura",
			"skeleton_king_mortal_strike",
			"skeleton_king_reincarnation"
		},
		trackedintrinsicmodifiers = {
			["skeleton_king_mortal_strike"] = {"modifier_skeleton_king_mortal_strike"}
		},
		logicthinkers = {
			{1, 1, nil, 2.0, nil, "skeleton_king_mortal_strike"},
			{2, 2, 3, 2.0, 600, "skeleton_king_vampiric_aura"}
		}
	},
	["npc_dota_hero_zuus"] = {
		abilities = {
			"zuus_arc_lightning",
			"zuus_lightning_bolt",
			"zuus_cloud",
			"zuus_thundergods_wrath"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_drow_ranger"] = {
		abilities = {
			"drow_ranger_frost_arrows",
			"drow_ranger_wave_of_silence",
			"drow_ranger_trueshot",
			"drow_ranger_marksmanship"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_tiny"] = {
		abilities = {
			"tiny_avalanche",
			"tiny_toss",
			"tiny_craggy_exterior",
			"tiny_grow",
			"tiny_toss_tree"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {
			{1, 4, nil, 4.0, nil, "tiny_craggy_exterior"}
		}
	},
	["npc_dota_hero_viper"] = {
		abilities = {
			"viper_poison_attack",
			"viper_nethertoxin",
			"viper_viper_strike"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_phantom_assassin"] = {
		abilities = {
			"phantom_assassin_stifling_dagger",
			"phantom_assassin_phantom_strike",
			"phantom_assassin_blur",
			"phantom_assassin_coup_de_grace"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	},
	["npc_dota_hero_lich"] = {
		abilities = {
			"lich_frost_nova",
			"lich_frost_shield",
			"lich_sinister_gaze",
			"lich_chain_frost"
		},
		trackedintrinsicmodifiers = {},
		logicthinkers = {}
	}
}

--Generic checks
function BotSupportLib:IsHeroBotControlled(hero)
	if hero ~= nil then
		local heroplayerID = hero:GetPlayerID()
		if PlayerResource:IsValidPlayer(heroplayerID) and PlayerResource:GetConnectionState(heroplayerID) == 1 then
			return true
		end
	end
	return false
end

function BotSupportLib:IsHeroBSLSupported(hero)
	if hero ~= nil then
		if affectedheroeslist[hero:GetName()] ~= nil then
			return true
		end
	end
	return false
end

--Database Calls
function BotSupportLib:GetAbilityFromDB(hero, name)
	if hero and name then
		if self.botdata[hero:entindex()].abilities[name] ~= nil then
			return self.botdata[hero:entindex()].abilities[name]
		end
	end
	return nil
end

function BotSupportLib:GetModifierFromDB(hero, name)
	if hero and name then
		if self.botdata[hero:entindex()].modifiers[name] ~= nil then
			if self.botdata[hero:entindex()].modifiers[name][2] == -1 or self.botdata[hero:entindex()].modifiers[name][2] > GameRules:GetDOTATime(false, false) then
				return self.botdata[hero:entindex()].modifiers[name][1]
			end
		end
	end
	return nil
end

function BotSupportLib:AddModifierToDB(hero, name, duration, overwrite)
	if not self.botdata[hero:entindex()].modifiers[name] then
		local timestamp = -1
		if duration and duration ~= -1 then
			timestamp = GameRules:GetDOTATime(false, false) + duration
		else
			timestamp = -1
		end
		table.insert(self.botdata[hero:entindex()].modifiers, name)
		self.botdata[hero:entindex()].modifiers[name] = {hero:FindModifierByName(name), timestamp}
	elseif self.botdata[hero:entindex()].modifiers[name] and overwrite then
		local timestamp = -1
		if duration and duration ~= -1 then
			timestamp = GameRules:GetDOTATime(false, false) + duration
		else
			timestamp = -1
		end
		self.botdata[hero:entindex()].modifiers[name] = {hero:FindModifierByName(name), timestamp}
	end
end

--call this OnAllHeroesSpawned
function BotSupportLib:StartBotInit()
	local heroes = HeroList:GetAllHeroes()
	--Attach OnAbilityFullyCast Event Handler
	GameRules.VGMAR.radiantanc:AddNewModifier(GameRules.VGMAR.radiantanc, nil, "modifier_bsl_eventhandler", {})
	for i=1,HeroList:GetHeroCount() do
		if self:IsHeroBotControlled(heroes[i]) then
			table.insert(self.botheroes, heroes[i])
		end
	end
	for k,v in ipairs(self.botheroes) do
		if self:IsHeroBSLSupported(v) then
			print("[BotSupportLib] :: Initiating "..HeroNamesLib:ConvertInternalToHeroName( v:GetName() ))
			self:InitBotHero(v)
		end
	end
	Timers:CreateTimer({
		endTime = 5,
		callback = function()
			BotSupportLib:GlobalBotThink()
			return 0.5
		end
	})
end

function BotSupportLib:InitBotHero(unit)
	if unit and unit:IsRealHero() then
		if not self.botdata[unit:entindex()] then
			local index = unit:entindex()
			local abilities = {}
			for k,v in ipairs(affectedheroeslist[unit:GetName()].abilities) do
				table.insert(abilities, v)
				print("[BSL]:Initializing "..v.." for "..unit:GetName())
				abilities[v] = unit:FindAbilityByName(v)
			end
			table.insert(self.botdata, index)
			self.botdata[index] = {hero = unit, name = unit:GetName(), abilities = abilities, modifiers = {}, thinkers = {}, abilitythinkers = {}}
			for i,j in ipairs(affectedheroeslist[unit:GetName()].logicthinkers) do
				local thinkerdata = affectedheroeslist[unit:GetName()].logicthinkers[i]
				self:AttachThinker(unit, thinkerdata[1], thinkerdata[2], thinkerdata[3], thinkerdata[6], thinkerdata[4], thinkerdata[5])
				print("[BSL]:--------------------------------------------------")
				print("[BSL]: Attached Thinker Modifier to "..HeroNamesLib:ConvertInternalToHeroName(unit:GetName()))
				print("[BSL]:Config for Thinker "..tostring(thinkerdata[1]))
				print("fID: "..tostring(thinkerdata[2]))
				print("endfID: "..tostring(thinkerdata[3]))
				print("Interval: "..tostring(thinkerdata[4]))
				print("Timeout: "..tostring(thinkerdata[5]))
				if thinkerdata[6] ~= nil and thinkerdata[6] ~= true then
					print("Ability: "..tostring(thinkerdata[6]))
				end
				print("[BSL]:--------------------------------------------------")
			end
		end
	end
end

--Condition Response
function BotSupportLib:GetAbilityCastManaConditions(hero, ability, addabilities, remainder)
	local manacost = ability:GetManaCost(-1)
	local mana = hero:GetMana()
	local manaregen = hero:GetManaRegen()
	if addabilities then
		for _,i in ipairs(addabilities) do
			if i:IsFullyCastable() then
				--print("[BSL]::ACMC: Manacost:"..i:GetName().."IsFullyCastable :+"..i:GetManaCost(-1))
				manacost = manacost + i:GetManaCost(-1)
			elseif i:GetCooldownTimeRemaining() < 10 and i:GetLevel() > 0 then
				if mana + (manaregen * i:GetCooldownTimeRemaining()) >= i:GetManaCost(-1) then
					--print("[BSL]::ACMC: Manacost:"..i:GetName().."Will be FullyCastable in "..i:GetCooldownTimeRemaining().." :+"..i:GetManaCost(-1))
					manacost = manacost + i:GetManaCost(-1)
				end
			end
		end
		--print("[BSL]::ACMC: Manacost after addabilities:"..manacost)
	end
	if remainder ~= nil then
		--print("[BSL]::ACMC: Remainder>Manacost:"..tostring((mana - manacost)/hero:GetMaxMana() >= remainder))
		return (mana - manacost)/hero:GetMaxMana() >= remainder
	end
	--print("[BSL]::ACMC: Manacost<Mana:"..tostring(manacost < mana))
	return manacost < mana
end

function BotSupportLib:GetAbilityCastConditions(hero, ability)
	if not ability then return false end
	if not ability:IsFullyCastable() then return false end
	if ability:IsHidden() then return false end
	if hero:IsChanneling() and ability ~= hero:GetCurrentActiveAbility() then return false end
	return true
end

--Generic AI functions
function BotSupportLib:GetLowestHealthEnemy(hero, range)
	local lowesthealthenemy = {99999999,nil}
	local enemies = FindUnitsInRadius(hero:GetTeamNumber(), hero:GetAbsOrigin(), nil, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, DOTA_UNIT_TARGET_FLAG_FOW_VISIBLE, FIND_CLOSEST, false)
	for _,enemy in ipairs(enemies) do
		if lowesthealthenemy[1] > enemy:GetHealth() and enemy:IsAlive() then
			lowesthealthenemy = {enemy:GetHealth(), enemy}
		end
	end
	if lowesthealthenemy[2] then
		return lowesthealthenemy[2]
	end
	return nil
end

function BotSupportLib:GetClosestEnemyHero(hero, range)
	local enemy = FindUnitsInRadius(hero:GetTeamNumber(), hero:GetAbsOrigin(), nil, range, DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO, DOTA_UNIT_TARGET_FLAG_FOW_VISIBLE, FIND_CLOSEST, false)
	if enemy[1] then
		return {enemy[1], (enemy[1]:GetAbsOrigin() - hero:GetAbsOrigin()):Length2D()}
	end
	return {nil, 9999999}
end

--[[[0] = "DOTA_UNIT_ORDER_NONE",
[1] = "DOTA_UNIT_ORDER_MOVE_TO_POSITION",
[2] = "DOTA_UNIT_ORDER_MOVE_TO_TARGET",
[3] = "DOTA_UNIT_ORDER_ATTACK_MOVE",
[4] = "DOTA_UNIT_ORDER_ATTACK_TARGET",
[5] = "DOTA_UNIT_ORDER_CAST_POSITION",
[6] = "DOTA_UNIT_ORDER_CAST_TARGET",
[7] = "DOTA_UNIT_ORDER_CAST_TARGET_TREE",
[8] = "DOTA_UNIT_ORDER_CAST_NO_TARGET", 
[9] = "DOTA_UNIT_ORDER_CAST_TOGGLE",
[10] = "DOTA_UNIT_ORDER_HOLD_POSITION",
[11] = "DOTA_UNIT_ORDER_TRAIN_ABILITY",
[12] = "DOTA_UNIT_ORDER_DROP_ITEM",
[13] = "DOTA_UNIT_ORDER_GIVE_ITEM",
[14] = "DOTA_UNIT_ORDER_PICKUP_ITEM",
[15] = "DOTA_UNIT_ORDER_PICKUP_RUNE",
[16] = "DOTA_UNIT_ORDER_PURCHASE_ITEM",
[17] = "DOTA_UNIT_ORDER_SELL_ITEM",
[18] = "DOTA_UNIT_ORDER_DISASSEMBLE_ITEM",
[19] = "DOTA_UNIT_ORDER_MOVE_ITEM",
[20] = "DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO",
[21] = "DOTA_UNIT_ORDER_STOP",
[22] = "DOTA_UNIT_ORDER_TAUNT",
[23] = "DOTA_UNIT_ORDER_BUYBACK",
[24] = "DOTA_UNIT_ORDER_GLYPH",
[25] = "DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH",
[26] = "DOTA_UNIT_ORDER_CAST_RUNE",
[27] = "DOTA_UNIT_ORDER_PING_ABILITY",
[28] = "DOTA_UNIT_ORDER_MOVE_TO_DIRECTION",
[29] = "DOTA_UNIT_ORDER_PATROL",
[30] = "DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION",
[31] = "DOTA_UNIT_ORDER_RADAR",
[32] = "DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK",
[33] = "DOTA_UNIT_ORDER_CONTINUE",
[34] = "DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED",
[35] = "DOTA_UNIT_ORDER_CAST_RIVER_PAINT"--]]

function BotSupportLib:CastAbility(hero, order_type, target, ability, position, queue, force, cancelondeath, interval, timeout)
	if hero then
		local tindex = nil
		local aindex = nil
		if target then
			if type(target) == "number" then
				tindex = target
			else
				tindex = target:entindex()
			end
		end
		if ability then
			if type(ability) == "number" then
				aindex = ability
				ability = EntIndexToHScript(aindex)
			else
				aindex = ability:entindex()
			end
			if ability:IsFullyCastable() then
				hero:AddNewModifier(hero, nil, "modifier_bsl_execute_order_processor", {
					ordertype = order_type,
					tindex = tindex,
					aindex = aindex,
					pos = position,
					queue = queue,
					force = force,
					cancelondeath = cancelondeath,
					timeout = timeout,
					interval = interval
				})
			end
		end
	end
end

--Adding Intrinsic Modifiers Tracking
function BotSupportLib:OnAbilityLearned( keys )
	local player = EntIndexToHScript(keys.player)
	local abilityname = keys.abilityname
	local playerhero = nil
	
	local heroes = HeroList:GetAllHeroes()
	for i=1,#self.botheroes do
		if self.botheroes[i] and self.botheroes[i]:GetPlayerOwner() == player then
			playerhero = self.botheroes[i]
			break
		end
	end
	if playerhero and playerhero:FindAbilityByName(abilityname) then
		local index = playerhero:entindex()
		if self:IsHeroBSLSupported(playerhero) then
			if self.botdata[index] then
				for k,v in pairs(affectedheroeslist[playerhero:GetName()].trackedintrinsicmodifiers) do
					if abilityname == k then
						for _,j in ipairs(v) do
							if not self.botdata[index].modifiers[j] then
								self:AddModifierToDB(playerhero, j, -1)
							end
						end
					end
				end
				for i,j in pairs(self.botdata[index].abilitythinkers) do
					if abilityname == i then
						for _,n in ipairs(j) do
							if n and n:IsNull() == false then
								n:StartIntervalThinkWithPresetInterval()
							end
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:GlobalBotThink()
	if GameRules:State_Get() >= DOTA_GAMERULES_STATE_PRE_GAME then
		local heroes = HeroList:GetAllHeroes()
		for i=0,HeroList:GetHeroCount() do
			local heroent = heroes[i]
			if heroent then
				if BotSupportLib:IsHeroBotControlled(heroent) then
					--////////////////////
					--Bot Bloodstone Usage
					--////////////////////
					if heroent:IsRealHero() and GameRules.VGMAR:HeroHasUsableItemInInventory( heroent, "item_bloodstone", false, false, false ) and heroent:IsAlive() then
						local bloodstone = GameRules.VGMAR:GetItemFromInventoryByName( heroent, "item_bloodstone", false, false, false )
						if bloodstone ~= nil and bloodstone:GetCooldownTimeRemaining() <= 0 and heroent:GetHealth()/heroent:GetMaxHealth() < 0.3 and heroent:GetMana()/heroent:GetMaxMana() > 0.6 then
							BotSupportLib:CastAbility(heroent, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, bloodstone, nil, false, true, true)
						end
					end
					--///////////////////////////////////
					--Butterfly Replacement(thx Valve /s)
					--///////////////////////////////////
					if heroent:IsRealHero() and GameRules.VGMAR:HeroHasUsableItemInInventory( heroent, "item_butterfly", false, false, false ) then
						local bfly = GameRules.VGMAR:GetItemFromInventoryByName( heroent, "item_butterfly", false, true, true )
						if bfly then
							GameRules.VGMAR:RemoveNItemsInInventory(heroent, "item_butterfly", 1)
							heroent:AddItemByName("item_butterfly_fixed")
						end
					end
				end
			end
		end
	end
end

--Events triggered by bsl_eventhandler
function BotSupportLib:OnAttackLanded(attacker, target, event)
	if event and attacker and target then
		local index = attacker:entindex()
		if self:IsHeroBSLSupported(attacker) then
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				if target:IsRealUnit(true) then
					if name == "npc_dota_hero_drow_ranger" then
						local ultimate = self:GetAbilityFromDB(attacker, "drow_ranger_marksmanship")
						local precisionaura = self:GetAbilityFromDB(attacker, "drow_ranger_trueshot")
						if target:IsBuilding() then
							if ultimate:GetLevel() > 0 and self:GetAbilityCastConditions(attacker, precisionaura) then
								self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, precisionaura, nil, false, true, true)
							end
						end
					elseif name == "npc_dota_hero_skeleton_king" then
						local crit = self:GetAbilityFromDB(attacker, "skeleton_king_mortal_strike")
						local reincarnation = self:GetAbilityFromDB(attacker, "skeleton_king_reincarnation")
						local skeletonsmodifier = self:GetModifierFromDB(attacker, "modifier_skeleton_king_mortal_strike")
						if target and (target:IsNeutralUnitType() or target:IsBuilding()) then
							if self:GetAbilityCastConditions(attacker, crit) and self:GetAbilityCastManaConditions(attacker, crit, {reincarnation}, 0.5) then
								if skeletonsmodifier and skeletonsmodifier:GetStackCount() >= crit:GetSpecialValueFor("max_skeleton_charges") then
									self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, crit, nil, false, true, true)
								end
							end
						end
					elseif name == "npc_dota_hero_lich" then
						local gaze = self:GetAbilityFromDB(attacker, "lich_sinister_gaze")
						local ultimate = self:GetAbilityFromDB(attacker, "lich_chain_frost")
						if target and target:IsHero() then
							if self:GetAbilityCastConditions(attacker, gaze) and self:GetAbilityCastManaConditions(attacker, gaze, {ultimate}, 0.3) then
								self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_TARGET, target, gaze, nil, false, true, true, 0.5, 2)
							end
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:OnAttackStart(attacker, target, event)
	if event and attacker and target then
		local index = attacker:entindex()
		if self:IsHeroBSLSupported(attacker) then
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				if name == "npc_dota_hero_sniper" then
					if target:IsHero() then
						local takeaim = self:GetAbilityFromDB(attacker, "sniper_take_aim")
						if self:GetAbilityCastConditions(attacker, takeaim) then
							self:CastAbility(attacker, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, takeaim, nil, false, true, true)
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:OnKilledUnit(attacker, unit, event)
	if attacker and unit and event then
		local index = attacker:entindex()
		if self:IsHeroBSLSupported(attacker) then
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				
			end
		end
	end
end

function BotSupportLib:OnDamaged(unit, attacker, event)
	if unit and attacker and event then
		local aindex = attacker:entindex()
		local uindex = unit:entindex()
		if self:IsHeroBSLSupported(attacker) then
			if self.botdata[aindex] ~= nil then
				local name = self.botdata[aindex].name
				
			end
		end
		if self:IsHeroBSLSupported(unit) then
			if self.botdata[uindex] ~= nil then
				local name = self.botdata[uindex].name
				if name == "npc_dota_hero_phantom_assassin" then
					local blur = self:GetAbilityFromDB(unit, "phantom_assassin_blur")
					if attacker:IsHero() and (unit:GetHealth()/unit:GetMaxHealth() < 0.7) then
						if BotSupportLib:GetClosestEnemyHero(attacker, -1)[2] > (blur:GetSpecialValueFor("radius")*1.15) then
							self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, blur, nil, false, true, true)
						end
					end
				elseif name == "npc_dota_hero_lich" then
					local shield = self:GetAbilityFromDB(unit, "lich_frost_shield")
					local ultimate = self:GetAbilityFromDB(unit, "lich_chain_frost")
					if self:GetAbilityCastConditions(unit, shield) and self:GetAbilityCastManaConditions(unit, shield, {ultimate}, 0.6) then
						if (unit:GetHealth()/unit:GetMaxHealth() < 0.7) then
							self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_TARGET, unit, shield, nil, false, true, true, 0.2, 2)
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:OnDeath(unit, attacker, event)
	if attacker and unit and event then
		local index = unit:entindex()
		if self:IsHeroBSLSupported(unit) then
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				
			end
		end
	end
end

--AbilityFullyCast Tracking
function BotSupportLib:OnAbilityCast(unit, ability, target, event)
	if event and unit and ability then
		local index = unit:entindex()
		--Check if hero has modifications
		if self:IsHeroBSLSupported(unit) then
			--BotLogic
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
				--Zeus
				if name == "npc_dota_hero_zuus" then
					local ultimate = self:GetAbilityFromDB( unit, "zuus_thundergods_wrath" )
					local nimbus = self:GetAbilityFromDB( unit ,"zuus_cloud" )
					local bolt = self:GetAbilityFromDB( unit, "zuus_lightning_bolt" )
					if ability == bolt then
						if self:GetAbilityCastConditions(unit, nimbus) and self:GetAbilityCastManaConditions(unit, nimbus, {}, 0.2) then
							if target and target:IsRealHero() then
								self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_POSITION, nil, nimbus, target:GetAbsOrigin(), false, true, true)
							end
						end
					elseif ability == ultimate then
						if self:GetAbilityCastConditions(unit, nimbus) and self:GetAbilityCastManaConditions(unit, nimbus, {}, 0.1) then
							Extensions:CallWithDelay(0.5, true, function()
								local enemy = self:GetLowestHealthEnemy(unit, -1)
								if enemy then
									self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_POSITION, nil, nimbus, enemy:GetAbsOrigin(), false, true, true)
								end
							end)
						end
					end
				--WraithKing
				elseif name == "npc_dota_hero_skeleton_king" then
					local stun = self:GetAbilityFromDB( unit, "skeleton_king_hellfire_blast")
					local aura = self:GetAbilityFromDB( unit, "skeleton_king_vampiric_aura")
					local crit = self:GetAbilityFromDB( unit, "skeleton_king_mortal_strike")
					local reincarnation = self:GetAbilityFromDB( unit, "skeleton_king_reincarnation")
					local skeletonsmodifier = self:GetModifierFromDB( unit, "modifier_skeleton_king_mortal_strike")
					if ability == stun then
						if target and target:IsHero() then
							if self:GetAbilityCastConditions(unit, crit) and self:GetAbilityCastManaConditions(unit, crit, {reincarnation}, 0.1) then
								if skeletonsmodifier and skeletonsmodifier:GetStackCount() >= crit:GetSpecialValueFor("max_skeleton_charges")/2 then
									self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, crit, nil, false, true, true)
								end
							end
						end
					end
				--Tiny
				elseif name == "npc_dota_hero_tiny" then
					local grab_tree = self:GetAbilityFromDB( unit, "tiny_craggy_exterior" )
					if ability == grab_tree then
						Extensions:CallWithDelay(0.5, true, function()
							self:AddModifierToDB(unit, "modifier_tiny_craggy_exterior", 15, true)
						end)
					end
				--Viper
				elseif name == "npc_dota_hero_viper" then
					local nethertoxin = self:GetAbilityFromDB( unit, "viper_nethertoxin" )
					local ultimate = self:GetAbilityFromDB( unit, "viper_viper_strike" )
					if ability == ultimate then
						if target and target:IsHero() then
							if self:GetAbilityCastConditions(unit, nethertoxin) and self:GetAbilityCastManaConditions(unit, nethertoxin, {}, 0.1) then
								self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_POSITION, nil, nethertoxin, target:GetAbsOrigin(), false, true, true)
							end
						end
					end
				--Lich
				elseif name == "npc_dota_hero_lich" then
					local blast = self:GetAbilityFromDB(unit, "lich_frost_nova")
					local gaze = self:GetAbilityFromDB(unit, "lich_sinister_gaze")
					local ultimate = self:GetAbilityFromDB(unit, "lich_chain_frost")
					if ability == blast or ability == ultimate then
						if target and target:IsHero() then
							if self:GetAbilityCastConditions(unit, gaze) and self:GetAbilityCastManaConditions(unit, gaze, {ultimate}, 0.1) then
								self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_TARGET, target, gaze, nil, false, true, true, 0.5, 1)
							end
						end
					end
				elseif name == "npc_dota_hero_phantom_assassin" then
					local blink = self:GetAbilityFromDB(unit, "phantom_assassin_phantom_strike")
					local blur = self:GetAbilityFromDB(unit, "phantom_assassin_blur")
					if ability == blink then
						if target and target:GetTeamNumber() == unit:GetTeamNumber() then
							if self:GetAbilityCastConditions(unit, blur) then
								Extensions:CallWithDelay(0.5, true, function()
									if BotSupportLib:GetClosestEnemyHero(unit, -1)[2] > (blur:GetSpecialValueFor("radius")*1.15) then
										self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, blur, nil, false, true, true, 0.3, 1)
									end
								end)
							end
						end
					end
				end
			end
		end
	end
end

function BotSupportLib:AttachThinker(unit, thinkerid, fID, endfID, autostart, interval, timeout)
	if unit then
		local index = unit:entindex()
		if not self.botdata[unit:entindex()].thinkers[thinkerid] then
			local thinker = nil
			if fID > 0 or endfID > 0 then
				thinker = unit:AddNewModifier(unit, nil, "modifier_bsl_thinker", {
						functionid = fID,
						endfID = endfID,
						interval = interval or 0.5,
						timeout = timeout,
						autostart = (autostart == true)
					})
				table.insert(self.botdata[index].thinkers, thinkerid)
				self.botdata[index].thinkers[thinkerid] = thinker
				if autostart ~= nil and autostart ~= true then
					if not self.botdata[index].abilitythinkers[autostart] then
						table.insert(self.botdata[index].abilitythinkers, autostart)
						self.botdata[index].abilitythinkers[autostart] = {}
					end
					table.insert(self.botdata[index].abilitythinkers[autostart], thinker)
				end
			end
		end
	end
end

--TODO:Add conditional attachment(similar to intrinsic modifier) function
function BotSupportLib:IntervalFunctionCall(unit, fID)
	--TODO:Giant if elseif tree/or a table of think functions
	if unit then
		local name = unit:GetName()
		--WK Idle Skeleton Spawning
		if fID == 1 then
			if name == "npc_dota_hero_skeleton_king" then
				if self:GetClosestEnemyHero(unit, 1500) == nil then
					local crit = self:GetAbilityFromDB( unit, "skeleton_king_mortal_strike")
					local reincarnation = self:GetAbilityFromDB( unit, "skeleton_king_reincarnation")
					local skeletonsmodifier = self:GetModifierFromDB( unit, "modifier_skeleton_king_mortal_strike")
					if self:GetAbilityCastConditions(unit, crit) and self:GetAbilityCastManaConditions(unit, crit, {reincarnation}, 0.5) then
						if skeletonsmodifier and skeletonsmodifier:GetStackCount() >= crit:GetSpecialValueFor("max_skeleton_charges") then
							self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_NO_TARGET, nil, crit, nil, false, true, true)
						end
					end
				end
			else
				return 2
			end
		--WK Aura Toggling on lane
		elseif fID == 2 then
			if name == "npc_dota_hero_skeleton_king" then
				local aura = self:GetAbilityFromDB(unit, "skeleton_king_vampiric_aura")
				if aura then
					local closesttower = FindUnitsInRadius(unit:GetTeamNumber(), unit:GetAbsOrigin(), nil, 2000, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_BUILDING, 0, FIND_CLOSEST, false)
					local idealstate = false
					if closesttower == nil then
						idealstate = true
					else
						idealstate = false
					end
					if aura:GetToggleState() ~= idealstate then
						aura:ToggleAbility()
					end
				end
			else
				return 2
			end
		--WK Aura Reenabling
		--OnRemoved Function
		elseif fID == 3 then
			if name == "npc_dota_hero_skeleton_king" then
				local aura = self:GetAbilityFromDB(unit, "skeleton_king_vampiric_aura")
				if aura then
					Timers:CreateTimer(2, function()
						if unit:IsAlive() then
							if aura:GetToggleState() ~= false then
								aura:ToggleAbility()
							end
						else
							return 2.0
						end
					end)
				end
			else
				return 2
			end
		--Tiny Grab Tree
		elseif fID == 4 then
			if name == "npc_dota_hero_tiny" then
				local tree_grab = self:GetAbilityFromDB(unit, "tiny_craggy_exterior")
				if unit:GetHealth()/unit:GetMaxHealth() > 0.6 and self:GetAbilityCastConditions(unit, tree_grab) and self:GetAbilityCastManaConditions(unit, tree_grab, {}, 0.2) then
					local tree = {nil,99999}
					for i,v in ipairs(GridNav:GetAllTreesAroundPoint(unit:GetAbsOrigin(), 600, true)) do
						if v:IsStanding() and GridNav:CanFindPath(v:GetAbsOrigin() + (v:GetAbsOrigin()-unit:GetAbsOrigin()):Normalized()*100, unit:GetAbsOrigin()) then
							local distance = (v:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D()
							if tree[2] > (v:GetAbsOrigin() - unit:GetAbsOrigin()):Length2D() then
								tree = {v, distance}
							end
						end
					end
					if tree[1] then
						tree = tree[1]:entindex()
						--[[unit:AddNewModifier(unit, nil, "modifier_bsl_execute_order_processor", {
							ordertype = DOTA_UNIT_ORDER_CAST_TARGET_TREE,
							tindex = GetTreeIdForEntityIndex(tree),
							aindex = tree_grab:entindex(),
							pos = nil,
							queue = false,
							force = true,
							interval = 0.1,
							timeout = 4
						})--]]
						self:CastAbility(unit, DOTA_UNIT_ORDER_CAST_TARGET_TREE, GetTreeIdForEntityIndex(tree), tree_grab, nil, false, true, true, 0.1, 4)
					end
				end
			else
				return 2
			end
		--Return Error Code if fID is not found
		else
			return 1
		end
	else
		return 3
	end
end

--OrderFilter Tracking
--Allows blocking actions
function BotSupportLib:OrderFilter(filterTable)
	local order_type = filterTable.order_type
	local units = filterTable["units"]
	local issuer = filterTable["issuer_player_id_const"]
	local unit = nil
	if units["0"] ~= nil then
		unit = EntIndexToHScript(units["0"])
	end
	local ability = EntIndexToHScript(filterTable.entindex_ability)
    local target = EntIndexToHScript(filterTable.entindex_target)
	
	if unit then
		local index = unit:entindex()
		--Check if hero has modifications
		if self:IsHeroBSLSupported(unit) then
			--BotLogic
			if self.botdata[index] ~= nil then
				local name = self.botdata[index].name
			end
		end
	end
end

--/////////////////////////////////
--Assignment
GameRules.BotSupportLib = BotSupportLib